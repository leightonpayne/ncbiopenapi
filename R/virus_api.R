#' NCBI Datasets API
#'
#' ### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 2 API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated zip archive](https://www.ncbi.nlm.nih.gov/datasets/docs/v2/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 
#'
#' The version of the OpenAPI document: v2
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Virus operations
#' @description VirusApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  Sars2ProteinDownload  ####################
#'
#' library(ncbiopenapi)
#' var_proteins <- c("inner_example") # array[character] | Which proteins to retrieve in the data package
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | Specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | List additional reports to include with download. Data report is included by default. (Optional)
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Download SARS-CoV-2 protein and CDS datasets by protein name
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Sars2ProteinDownload(var_proteins, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$Sars2ProteinDownload(var_proteins, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  Sars2ProteinDownloadPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_sars2_protein_dataset_request <- v2Sars2ProteinDatasetRequest$new(c("proteins_example"), "refseq_only_example", "annotated_only_example", "released_since_example", "updated_since_example", "host_example", "pangolin_classification_example", "geo_location_example", "usa_state_example", "complete_only_example", c(v2VirusTableField$new()), c(v2ViralSequenceType$new()), c(v2VirusDatasetReportType$new()), v2TableFormat$new()) # V2Sars2ProteinDatasetRequest | 
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Download SARS-CoV-2 protein and CDS datasets by protein name by POST request
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Sars2ProteinDownloadPost(var_v2_sars2_protein_dataset_request, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$Sars2ProteinDownloadPost(var_v2_sars2_protein_dataset_request, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  Sars2ProteinSummary  ####################
#'
#' library(ncbiopenapi)
#' var_proteins <- c("inner_example") # array[character] | Which proteins to retrieve in the data package
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | Specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | List additional reports to include with download. Data report is included by default. (Optional)
#'
#' #Summary of SARS-CoV-2 protein and CDS datasets by protein name
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Sars2ProteinSummary(var_proteins, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_reportdata_file = "result.txt")
#' result <- api_instance$Sars2ProteinSummary(var_proteins, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report)
#' dput(result)
#'
#'
#' ####################  Sars2ProteinSummaryByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_sars2_protein_dataset_request <- v2Sars2ProteinDatasetRequest$new(c("proteins_example"), "refseq_only_example", "annotated_only_example", "released_since_example", "updated_since_example", "host_example", "pangolin_classification_example", "geo_location_example", "usa_state_example", "complete_only_example", c(v2VirusTableField$new()), c(v2ViralSequenceType$new()), c(v2VirusDatasetReportType$new()), v2TableFormat$new()) # V2Sars2ProteinDatasetRequest | 
#'
#' #Summary of SARS-CoV-2 protein and CDS datasets by protein name
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Sars2ProteinSummaryByPost(var_v2_sars2_protein_dataset_requestdata_file = "result.txt")
#' result <- api_instance$Sars2ProteinSummaryByPost(var_v2_sars2_protein_dataset_request)
#' dput(result)
#'
#'
#' ####################  Sars2ProteinTable  ####################
#'
#' library(ncbiopenapi)
#' var_proteins <- c("inner_example") # array[character] | Which proteins to retrieve in the data package
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_table_fields <- c(v2VirusTableField$new()) # array[V2VirusTableField] | Specify which fields to include in the tabular report (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | Specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | List additional reports to include with download. Data report is included by default. (Optional)
#' var_format <- v2TableFormat$new() # V2TableFormat | Choose download format (tsv, csv or jsonl) (Optional)
#'
#' #Get SARS-CoV-2 protein metadata in a tabular format.
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Sars2ProteinTable(var_proteins, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, table_fields = var_table_fields, include_sequence = var_include_sequence, aux_report = var_aux_report, format = var_formatdata_file = "result.txt")
#' result <- api_instance$Sars2ProteinTable(var_proteins, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, table_fields = var_table_fields, include_sequence = var_include_sequence, aux_report = var_aux_report, format = var_format)
#' dput(result)
#'
#'
#' ####################  VirusAccessionAvailability  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | virus accessions
#'
#' #Check available viruses by accession
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusAccessionAvailability(var_accessionsdata_file = "result.txt")
#' result <- api_instance$VirusAccessionAvailability(var_accessions)
#' dput(result)
#'
#'
#' ####################  VirusAccessionAvailabilityPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_virus_availability_request <- v2VirusAvailabilityRequest$new(c("accessions_example")) # V2VirusAvailabilityRequest | 
#'
#' #Check available viruses by accession
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusAccessionAvailabilityPost(var_v2_virus_availability_requestdata_file = "result.txt")
#' result <- api_instance$VirusAccessionAvailabilityPost(var_v2_virus_availability_request)
#' dput(result)
#'
#'
#' ####################  VirusAnnotationReportsByAcessions  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | genome sequence accessions
#' var_filter_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_filter_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_filter_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_filter_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_filter_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_filter_pangolin_classification <- "filter_pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_filter_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_filter_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_filter_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_page_size <- 20 # integer | The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#'
#' #Get virus annotation report by accession
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusAnnotationReportsByAcessions(var_accessions, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_tokendata_file = "result.txt")
#' result <- api_instance$VirusAnnotationReportsByAcessions(var_accessions, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_token)
#' dput(result)
#'
#'
#' ####################  VirusAnnotationReportsByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_virus_annotation_report_request <- v2VirusAnnotationReportRequest$new(v2VirusAnnotationFilter$new(c("accessions_example"), "taxon_example", c("taxons_example"), "refseq_only_example", "annotated_only_example", "released_since_example", "updated_since_example", "host_example", "pangolin_classification_example", "geo_location_example", "usa_state_example", "complete_only_example"), c("table_fields_example"), "table_format_example", 123, "page_token_example") # V2VirusAnnotationReportRequest | 
#'
#' #Get virus annotation report by POST
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusAnnotationReportsByPost(var_v2_virus_annotation_report_requestdata_file = "result.txt")
#' result <- api_instance$VirusAnnotationReportsByPost(var_v2_virus_annotation_report_request)
#' dput(result)
#'
#'
#' ####################  VirusAnnotationReportsByTaxon  ####################
#'
#' library(ncbiopenapi)
#' var_taxon <- "1335626" # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var_filter_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_filter_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_filter_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_filter_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_filter_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_filter_pangolin_classification <- "filter_pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_filter_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_filter_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_filter_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_page_size <- 20 # integer | The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#'
#' #Get virus annotation report by taxon
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusAnnotationReportsByTaxon(var_taxon, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_tokendata_file = "result.txt")
#' result <- api_instance$VirusAnnotationReportsByTaxon(var_taxon, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_token)
#' dput(result)
#'
#'
#' ####################  VirusGenomeDownload  ####################
#'
#' library(ncbiopenapi)
#' var_taxon <- "1335626" # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var_taxons <- c("inner_example") # array[character] | NCBI Taxonomy IDs or names (common or scientific) at any taxonomic rank (Optional)
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | list additional reports to include with download. Data report is included by default. (Optional)
#' var_use_psg <- "use_psg_example" # character | Experimental approach to retrieving sequence data. (Optional)
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Download a virus genome dataset by taxon
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusGenomeDownload(var_taxon, taxons = var_taxons, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report, use_psg = var_use_psg, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$VirusGenomeDownload(var_taxon, taxons = var_taxons, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report, use_psg = var_use_psg, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  VirusGenomeDownloadAccession  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | genome sequence accessions
#' var_taxons <- c("inner_example") # array[character] | NCBI Taxonomy IDs or names (common or scientific) at any taxonomic rank (Optional)
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | list additional reports to include with download. Data report is included by default. (Optional)
#' var_use_psg <- "use_psg_example" # character | Experimental approach to retrieving sequence data. (Optional)
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Download a virus genome dataset by accession
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusGenomeDownloadAccession(var_accessions, taxons = var_taxons, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report, use_psg = var_use_psg, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$VirusGenomeDownloadAccession(var_accessions, taxons = var_taxons, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report, use_psg = var_use_psg, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  VirusGenomeDownloadPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_virus_dataset_request <- v2VirusDatasetRequest$new(c("accessions_example"), "taxon_example", c("taxons_example"), "refseq_only_example", "annotated_only_example", "released_since_example", "updated_since_example", "host_example", "pangolin_classification_example", "geo_location_example", "usa_state_example", "complete_only_example", c(v2VirusTableField$new()), c(v2ViralSequenceType$new()), c(v2VirusDatasetReportType$new()), v2TableFormat$new(), "use_psg_example") # V2VirusDatasetRequest | 
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Get a virus genome dataset by post
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusGenomeDownloadPost(var_v2_virus_dataset_request, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$VirusGenomeDownloadPost(var_v2_virus_dataset_request, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  VirusGenomeSummary  ####################
#'
#' library(ncbiopenapi)
#' var_taxon <- "1335626" # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var_accessions <- c("inner_example") # array[character] | genome sequence accessions (Optional)
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | list additional reports to include with download. Data report is included by default. (Optional)
#'
#' #Get summary data for virus genomes by taxon
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusGenomeSummary(var_taxon, accessions = var_accessions, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_reportdata_file = "result.txt")
#' result <- api_instance$VirusGenomeSummary(var_taxon, accessions = var_accessions, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, include_sequence = var_include_sequence, aux_report = var_aux_report)
#' dput(result)
#'
#'
#' ####################  VirusGenomeSummaryByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_virus_dataset_request <- v2VirusDatasetRequest$new(c("accessions_example"), "taxon_example", c("taxons_example"), "refseq_only_example", "annotated_only_example", "released_since_example", "updated_since_example", "host_example", "pangolin_classification_example", "geo_location_example", "usa_state_example", "complete_only_example", c(v2VirusTableField$new()), c(v2ViralSequenceType$new()), c(v2VirusDatasetReportType$new()), v2TableFormat$new(), "use_psg_example") # V2VirusDatasetRequest | 
#'
#' #Get summary data for virus genomes by post
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusGenomeSummaryByPost(var_v2_virus_dataset_requestdata_file = "result.txt")
#' result <- api_instance$VirusGenomeSummaryByPost(var_v2_virus_dataset_request)
#' dput(result)
#'
#'
#' ####################  VirusGenomeTable  ####################
#'
#' library(ncbiopenapi)
#' var_taxon <- "1335626" # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var_accessions <- c("inner_example") # array[character] | genome sequence accessions (Optional)
#' var_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_pangolin_classification <- "pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_table_fields <- c(v2VirusTableField$new()) # array[V2VirusTableField] | Specify which fields to include in the tabular report (Optional)
#' var_include_sequence <- c(v2ViralSequenceType$new()) # array[V2ViralSequenceType] | specify which sequence files to include in the download (Optional)
#' var_aux_report <- c(v2VirusDatasetReportType$new()) # array[V2VirusDatasetReportType] | list additional reports to include with download. Data report is included by default. (Optional)
#' var_format <- v2TableFormat$new() # V2TableFormat | Choose download format (tsv, csv or jsonl) (Optional)
#'
#' #Get virus genome metadata in a tabular format.
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusGenomeTable(var_taxon, accessions = var_accessions, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, table_fields = var_table_fields, include_sequence = var_include_sequence, aux_report = var_aux_report, format = var_formatdata_file = "result.txt")
#' result <- api_instance$VirusGenomeTable(var_taxon, accessions = var_accessions, refseq_only = var_refseq_only, annotated_only = var_annotated_only, released_since = var_released_since, updated_since = var_updated_since, host = var_host, pangolin_classification = var_pangolin_classification, geo_location = var_geo_location, usa_state = var_usa_state, complete_only = var_complete_only, table_fields = var_table_fields, include_sequence = var_include_sequence, aux_report = var_aux_report, format = var_format)
#' dput(result)
#'
#'
#' ####################  VirusReportsByAcessions  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | genome sequence accessions
#' var_filter_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_filter_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_filter_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_filter_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_filter_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_filter_pangolin_classification <- "filter_pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_filter_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_filter_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_filter_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_returned_content <- v2VirusDataReportRequestContentType$new() # V2VirusDataReportRequestContentType | Return either virus genome accessions, or complete virus metadata (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_page_size <- 20 # integer | The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#'
#' #Get virus metadata by accession
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusReportsByAcessions(var_accessions, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, returned_content = var_returned_content, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_tokendata_file = "result.txt")
#' result <- api_instance$VirusReportsByAcessions(var_accessions, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, returned_content = var_returned_content, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_token)
#' dput(result)
#'
#'
#' ####################  VirusReportsByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_virus_data_report_request <- v2VirusDataReportRequest$new(v2VirusDatasetFilter$new(c("accessions_example"), "taxon_example", c("taxons_example"), "refseq_only_example", "annotated_only_example", "released_since_example", "updated_since_example", "host_example", "pangolin_classification_example", "geo_location_example", "usa_state_example", "complete_only_example"), v2VirusDataReportRequestContentType$new(), c("table_fields_example"), "table_format_example", 123, "page_token_example") # V2VirusDataReportRequest | 
#'
#' #Get virus metadata by POST
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusReportsByPost(var_v2_virus_data_report_requestdata_file = "result.txt")
#' result <- api_instance$VirusReportsByPost(var_v2_virus_data_report_request)
#' dput(result)
#'
#'
#' ####################  VirusReportsByTaxon  ####################
#'
#' library(ncbiopenapi)
#' var_taxon <- "1335626" # character | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var_filter_refseq_only <- FALSE # character | If true, limit results to RefSeq genomes. (Optional)
#' var_filter_annotated_only <- FALSE # character | If true, limit results to annotated genomes. (Optional)
#' var_filter_released_since <- "2020-08-01T00:00:00Z" # character | If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z' (Optional)
#' var_filter_updated_since <- "2021-07-18T00:00:00Z" # character |  (Optional)
#' var_filter_host <- "human" # character | If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default (Optional)
#' var_filter_pangolin_classification <- "filter_pangolin_classification_example" # character | If set, limit results to genomes classified to this lineage by the PangoLearn tool. (Optional)
#' var_filter_geo_location <- "USA" # character | Assemblies from this location (country or continent) (Optional)
#' var_filter_usa_state <- "CA" # character | Assemblies from this state (official two letter code only) (Optional)
#' var_filter_complete_only <- FALSE # character | only include complete genomes. (Optional)
#' var_returned_content <- v2VirusDataReportRequestContentType$new() # V2VirusDataReportRequestContentType | Return either virus genome accessions, or complete virus metadata (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_page_size <- 20 # integer | The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#'
#' #Get virus metadata by taxon
#' api_instance <- VirusApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$VirusReportsByTaxon(var_taxon, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, returned_content = var_returned_content, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_tokendata_file = "result.txt")
#' result <- api_instance$VirusReportsByTaxon(var_taxon, filter_refseq_only = var_filter_refseq_only, filter_annotated_only = var_filter_annotated_only, filter_released_since = var_filter_released_since, filter_updated_since = var_filter_updated_since, filter_host = var_filter_host, filter_pangolin_classification = var_filter_pangolin_classification, filter_geo_location = var_filter_geo_location, filter_usa_state = var_filter_usa_state, filter_complete_only = var_filter_complete_only, returned_content = var_returned_content, table_fields = var_table_fields, page_size = var_page_size, page_token = var_page_token)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
VirusApi <- R6::R6Class(
  "VirusApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new VirusApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Download SARS-CoV-2 protein and CDS datasets by protein name
    #'
    #' @param proteins Which proteins to retrieve in the data package
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) Specify which sequence files to include in the download
    #' @param aux_report (optional) List additional reports to include with download. Data report is included by default.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    Sars2ProteinDownload = function(proteins, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$Sars2ProteinDownloadWithHttpInfo(proteins, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, include_sequence, aux_report, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Download SARS-CoV-2 protein and CDS datasets by protein name
    #'
    #' @param proteins Which proteins to retrieve in the data package
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) Specify which sequence files to include in the download
    #' @param aux_report (optional) List additional reports to include with download. Data report is included by default.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    Sars2ProteinDownloadWithHttpInfo = function(proteins, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`proteins`)) {
        stop("Missing required parameter `proteins`.")
      }














      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      query_params[["filename"]] <- `filename`

      local_var_url_path <- "/virus/taxon/sars2/protein/{proteins}/download"
      if (!missing(`proteins`)) {
        local_var_url_path <- gsub("\\{proteins\\}", paste(URLencode(as.character(`proteins`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Download SARS-CoV-2 protein and CDS datasets by protein name by POST request
    #'
    #' @param v2_sars2_protein_dataset_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    Sars2ProteinDownloadPost = function(v2_sars2_protein_dataset_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$Sars2ProteinDownloadPostWithHttpInfo(v2_sars2_protein_dataset_request, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Download SARS-CoV-2 protein and CDS datasets by protein name by POST request
    #'
    #' @param v2_sars2_protein_dataset_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    Sars2ProteinDownloadPostWithHttpInfo = function(v2_sars2_protein_dataset_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_sars2_protein_dataset_request`)) {
        stop("Missing required parameter `v2_sars2_protein_dataset_request`.")
      }



      query_params[["filename"]] <- `filename`

      if (!is.null(`v2_sars2_protein_dataset_request`)) {
        local_var_body <- `v2_sars2_protein_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus/taxon/sars2/protein/download"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Summary of SARS-CoV-2 protein and CDS datasets by protein name
    #'
    #' @param proteins Which proteins to retrieve in the data package
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) Specify which sequence files to include in the download
    #' @param aux_report (optional) List additional reports to include with download. Data report is included by default.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    Sars2ProteinSummary = function(proteins, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, data_file = NULL, ...) {
      local_var_response <- self$Sars2ProteinSummaryWithHttpInfo(proteins, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, include_sequence, aux_report, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Summary of SARS-CoV-2 protein and CDS datasets by protein name
    #'
    #' @param proteins Which proteins to retrieve in the data package
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) Specify which sequence files to include in the download
    #' @param aux_report (optional) List additional reports to include with download. Data report is included by default.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    Sars2ProteinSummaryWithHttpInfo = function(proteins, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`proteins`)) {
        stop("Missing required parameter `proteins`.")
      }













      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      local_var_url_path <- "/virus/taxon/sars2/protein/{proteins}"
      if (!missing(`proteins`)) {
        local_var_url_path <- gsub("\\{proteins\\}", paste(URLencode(as.character(`proteins`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Summary of SARS-CoV-2 protein and CDS datasets by protein name
    #'
    #' @param v2_sars2_protein_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    Sars2ProteinSummaryByPost = function(v2_sars2_protein_dataset_request, data_file = NULL, ...) {
      local_var_response <- self$Sars2ProteinSummaryByPostWithHttpInfo(v2_sars2_protein_dataset_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Summary of SARS-CoV-2 protein and CDS datasets by protein name
    #'
    #' @param v2_sars2_protein_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    Sars2ProteinSummaryByPostWithHttpInfo = function(v2_sars2_protein_dataset_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_sars2_protein_dataset_request`)) {
        stop("Missing required parameter `v2_sars2_protein_dataset_request`.")
      }


      if (!is.null(`v2_sars2_protein_dataset_request`)) {
        local_var_body <- `v2_sars2_protein_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus/taxon/sars2/protein"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get SARS-CoV-2 protein metadata in a tabular format.
    #'
    #' @param proteins Which proteins to retrieve in the data package
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param include_sequence (optional) Specify which sequence files to include in the download
    #' @param aux_report (optional) List additional reports to include with download. Data report is included by default.
    #' @param format (optional) Choose download format (tsv, csv or jsonl)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2TabularOutput
    Sars2ProteinTable = function(proteins, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, table_fields = NULL, include_sequence = NULL, aux_report = NULL, format = NULL, data_file = NULL, ...) {
      local_var_response <- self$Sars2ProteinTableWithHttpInfo(proteins, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, table_fields, include_sequence, aux_report, format, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get SARS-CoV-2 protein metadata in a tabular format.
    #'
    #' @param proteins Which proteins to retrieve in the data package
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param include_sequence (optional) Specify which sequence files to include in the download
    #' @param aux_report (optional) List additional reports to include with download. Data report is included by default.
    #' @param format (optional) Choose download format (tsv, csv or jsonl)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2TabularOutput) with additional information such as HTTP status code, headers
    Sars2ProteinTableWithHttpInfo = function(proteins, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, table_fields = NULL, include_sequence = NULL, aux_report = NULL, format = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`proteins`)) {
        stop("Missing required parameter `proteins`.")
      }















      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      query_params[["format"]] <- `format`

      local_var_url_path <- "/virus/taxon/sars2/protein/{proteins}/table"
      if (!missing(`proteins`)) {
        local_var_url_path <- gsub("\\{proteins\\}", paste(URLencode(as.character(`proteins`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2TabularOutput"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Check available viruses by accession
    #'
    #' @param accessions virus accessions
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2VirusAvailability
    VirusAccessionAvailability = function(accessions, data_file = NULL, ...) {
      local_var_response <- self$VirusAccessionAvailabilityWithHttpInfo(accessions, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Check available viruses by accession
    #'
    #' @param accessions virus accessions
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2VirusAvailability) with additional information such as HTTP status code, headers
    VirusAccessionAvailabilityWithHttpInfo = function(accessions, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }


      local_var_url_path <- "/virus/accession/{accessions}/check"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2VirusAvailability"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Check available viruses by accession
    #'
    #' @param v2_virus_availability_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2VirusAvailability
    VirusAccessionAvailabilityPost = function(v2_virus_availability_request, data_file = NULL, ...) {
      local_var_response <- self$VirusAccessionAvailabilityPostWithHttpInfo(v2_virus_availability_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Check available viruses by accession
    #'
    #' @param v2_virus_availability_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2VirusAvailability) with additional information such as HTTP status code, headers
    VirusAccessionAvailabilityPostWithHttpInfo = function(v2_virus_availability_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_virus_availability_request`)) {
        stop("Missing required parameter `v2_virus_availability_request`.")
      }


      if (!is.null(`v2_virus_availability_request`)) {
        local_var_body <- `v2_virus_availability_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus/check"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2VirusAvailability"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus annotation report by accession
    #'
    #' @param accessions genome sequence accessions
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsVirusAnnotationReportPage
    VirusAnnotationReportsByAcessions = function(accessions, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      local_var_response <- self$VirusAnnotationReportsByAcessionsWithHttpInfo(accessions, filter_refseq_only, filter_annotated_only, filter_released_since, filter_updated_since, filter_host, filter_pangolin_classification, filter_geo_location, filter_usa_state, filter_complete_only, table_fields, page_size, page_token, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus annotation report by accession
    #'
    #' @param accessions genome sequence accessions
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsVirusAnnotationReportPage) with additional information such as HTTP status code, headers
    VirusAnnotationReportsByAcessionsWithHttpInfo = function(accessions, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }














      query_params[["filter.refseq_only"]] <- `filter_refseq_only`

      query_params[["filter.annotated_only"]] <- `filter_annotated_only`

      query_params[["filter.released_since"]] <- `filter_released_since`

      query_params[["filter.updated_since"]] <- `filter_updated_since`

      query_params[["filter.host"]] <- `filter_host`

      query_params[["filter.pangolin_classification"]] <- `filter_pangolin_classification`

      query_params[["filter.geo_location"]] <- `filter_geo_location`

      query_params[["filter.usa_state"]] <- `filter_usa_state`

      query_params[["filter.complete_only"]] <- `filter_complete_only`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      local_var_url_path <- "/virus/accession/{accessions}/annotation_report"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsVirusAnnotationReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus annotation report by POST
    #'
    #' @param v2_virus_annotation_report_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsVirusAnnotationReportPage
    VirusAnnotationReportsByPost = function(v2_virus_annotation_report_request, data_file = NULL, ...) {
      local_var_response <- self$VirusAnnotationReportsByPostWithHttpInfo(v2_virus_annotation_report_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus annotation report by POST
    #'
    #' @param v2_virus_annotation_report_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsVirusAnnotationReportPage) with additional information such as HTTP status code, headers
    VirusAnnotationReportsByPostWithHttpInfo = function(v2_virus_annotation_report_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_virus_annotation_report_request`)) {
        stop("Missing required parameter `v2_virus_annotation_report_request`.")
      }


      if (!is.null(`v2_virus_annotation_report_request`)) {
        local_var_body <- `v2_virus_annotation_report_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus/annotation_report"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsVirusAnnotationReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus annotation report by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsVirusAnnotationReportPage
    VirusAnnotationReportsByTaxon = function(taxon, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      local_var_response <- self$VirusAnnotationReportsByTaxonWithHttpInfo(taxon, filter_refseq_only, filter_annotated_only, filter_released_since, filter_updated_since, filter_host, filter_pangolin_classification, filter_geo_location, filter_usa_state, filter_complete_only, table_fields, page_size, page_token, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus annotation report by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsVirusAnnotationReportPage) with additional information such as HTTP status code, headers
    VirusAnnotationReportsByTaxonWithHttpInfo = function(taxon, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }














      query_params[["filter.refseq_only"]] <- `filter_refseq_only`

      query_params[["filter.annotated_only"]] <- `filter_annotated_only`

      query_params[["filter.released_since"]] <- `filter_released_since`

      query_params[["filter.updated_since"]] <- `filter_updated_since`

      query_params[["filter.host"]] <- `filter_host`

      query_params[["filter.pangolin_classification"]] <- `filter_pangolin_classification`

      query_params[["filter.geo_location"]] <- `filter_geo_location`

      query_params[["filter.usa_state"]] <- `filter_usa_state`

      query_params[["filter.complete_only"]] <- `filter_complete_only`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      local_var_url_path <- "/virus/taxon/{taxon}/annotation_report"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub("\\{taxon\\}", URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsVirusAnnotationReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Download a virus genome dataset by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param taxons (optional) NCBI Taxonomy IDs or names (common or scientific) at any taxonomic rank
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param use_psg (optional) Experimental approach to retrieving sequence data.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    VirusGenomeDownload = function(taxon, taxons = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, use_psg = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$VirusGenomeDownloadWithHttpInfo(taxon, taxons, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, include_sequence, aux_report, use_psg, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Download a virus genome dataset by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param taxons (optional) NCBI Taxonomy IDs or names (common or scientific) at any taxonomic rank
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param use_psg (optional) Experimental approach to retrieving sequence data.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    VirusGenomeDownloadWithHttpInfo = function(taxon, taxons = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, use_psg = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }
















      # explore
      for (query_item in `taxons`) {
        query_params[["taxons"]] <- c(query_params[["taxons"]], list(`taxons` = query_item))
      }

      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      query_params[["use_psg"]] <- `use_psg`

      query_params[["filename"]] <- `filename`

      local_var_url_path <- "/virus/taxon/{taxon}/genome/download"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub("\\{taxon\\}", URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Download a virus genome dataset by accession
    #'
    #' @param accessions genome sequence accessions
    #' @param taxons (optional) NCBI Taxonomy IDs or names (common or scientific) at any taxonomic rank
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param use_psg (optional) Experimental approach to retrieving sequence data.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    VirusGenomeDownloadAccession = function(accessions, taxons = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, use_psg = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$VirusGenomeDownloadAccessionWithHttpInfo(accessions, taxons, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, include_sequence, aux_report, use_psg, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Download a virus genome dataset by accession
    #'
    #' @param accessions genome sequence accessions
    #' @param taxons (optional) NCBI Taxonomy IDs or names (common or scientific) at any taxonomic rank
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param use_psg (optional) Experimental approach to retrieving sequence data.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    VirusGenomeDownloadAccessionWithHttpInfo = function(accessions, taxons = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, use_psg = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }
















      # explore
      for (query_item in `taxons`) {
        query_params[["taxons"]] <- c(query_params[["taxons"]], list(`taxons` = query_item))
      }

      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      query_params[["use_psg"]] <- `use_psg`

      query_params[["filename"]] <- `filename`

      local_var_url_path <- "/virus/accession/{accessions}/genome/download"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get a virus genome dataset by post
    #'
    #' @param v2_virus_dataset_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    VirusGenomeDownloadPost = function(v2_virus_dataset_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$VirusGenomeDownloadPostWithHttpInfo(v2_virus_dataset_request, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get a virus genome dataset by post
    #'
    #' @param v2_virus_dataset_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    VirusGenomeDownloadPostWithHttpInfo = function(v2_virus_dataset_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_virus_dataset_request`)) {
        stop("Missing required parameter `v2_virus_dataset_request`.")
      }



      query_params[["filename"]] <- `filename`

      if (!is.null(`v2_virus_dataset_request`)) {
        local_var_body <- `v2_virus_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus/genome/download"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get summary data for virus genomes by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param accessions (optional) genome sequence accessions
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    VirusGenomeSummary = function(taxon, accessions = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, data_file = NULL, ...) {
      local_var_response <- self$VirusGenomeSummaryWithHttpInfo(taxon, accessions, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, include_sequence, aux_report, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get summary data for virus genomes by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param accessions (optional) genome sequence accessions
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    VirusGenomeSummaryWithHttpInfo = function(taxon, accessions = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, include_sequence = NULL, aux_report = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }














      # explore
      for (query_item in `accessions`) {
        query_params[["accessions"]] <- c(query_params[["accessions"]], list(`accessions` = query_item))
      }

      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      local_var_url_path <- "/virus/taxon/{taxon}/genome"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub("\\{taxon\\}", URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get summary data for virus genomes by post
    #'
    #' @param v2_virus_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    VirusGenomeSummaryByPost = function(v2_virus_dataset_request, data_file = NULL, ...) {
      local_var_response <- self$VirusGenomeSummaryByPostWithHttpInfo(v2_virus_dataset_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get summary data for virus genomes by post
    #'
    #' @param v2_virus_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    VirusGenomeSummaryByPostWithHttpInfo = function(v2_virus_dataset_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_virus_dataset_request`)) {
        stop("Missing required parameter `v2_virus_dataset_request`.")
      }


      if (!is.null(`v2_virus_dataset_request`)) {
        local_var_body <- `v2_virus_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus/genome"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus genome metadata in a tabular format.
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param accessions (optional) genome sequence accessions
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param format (optional) Choose download format (tsv, csv or jsonl)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2TabularOutput
    VirusGenomeTable = function(taxon, accessions = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, table_fields = NULL, include_sequence = NULL, aux_report = NULL, format = NULL, data_file = NULL, ...) {
      local_var_response <- self$VirusGenomeTableWithHttpInfo(taxon, accessions, refseq_only, annotated_only, released_since, updated_since, host, pangolin_classification, geo_location, usa_state, complete_only, table_fields, include_sequence, aux_report, format, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus genome metadata in a tabular format.
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param accessions (optional) genome sequence accessions
    #' @param refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param updated_since (optional) No description
    #' @param host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param geo_location (optional) Assemblies from this location (country or continent)
    #' @param usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param include_sequence (optional) specify which sequence files to include in the download
    #' @param aux_report (optional) list additional reports to include with download. Data report is included by default.
    #' @param format (optional) Choose download format (tsv, csv or jsonl)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2TabularOutput) with additional information such as HTTP status code, headers
    VirusGenomeTableWithHttpInfo = function(taxon, accessions = NULL, refseq_only = FALSE, annotated_only = FALSE, released_since = NULL, updated_since = NULL, host = NULL, pangolin_classification = NULL, geo_location = NULL, usa_state = NULL, complete_only = FALSE, table_fields = NULL, include_sequence = NULL, aux_report = NULL, format = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }
















      # explore
      for (query_item in `accessions`) {
        query_params[["accessions"]] <- c(query_params[["accessions"]], list(`accessions` = query_item))
      }

      query_params[["refseq_only"]] <- `refseq_only`

      query_params[["annotated_only"]] <- `annotated_only`

      query_params[["released_since"]] <- `released_since`

      query_params[["updated_since"]] <- `updated_since`

      query_params[["host"]] <- `host`

      query_params[["pangolin_classification"]] <- `pangolin_classification`

      query_params[["geo_location"]] <- `geo_location`

      query_params[["usa_state"]] <- `usa_state`

      query_params[["complete_only"]] <- `complete_only`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      # explore
      for (query_item in `include_sequence`) {
        query_params[["include_sequence"]] <- c(query_params[["include_sequence"]], list(`include_sequence` = query_item))
      }

      # explore
      for (query_item in `aux_report`) {
        query_params[["aux_report"]] <- c(query_params[["aux_report"]], list(`aux_report` = query_item))
      }

      query_params[["format"]] <- `format`

      local_var_url_path <- "/virus/taxon/{taxon}/genome/table"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub("\\{taxon\\}", URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2TabularOutput"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus metadata by accession
    #'
    #' @param accessions genome sequence accessions
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param returned_content (optional) Return either virus genome accessions, or complete virus metadata
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsVirusDataReportPage
    VirusReportsByAcessions = function(accessions, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, returned_content = NULL, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      local_var_response <- self$VirusReportsByAcessionsWithHttpInfo(accessions, filter_refseq_only, filter_annotated_only, filter_released_since, filter_updated_since, filter_host, filter_pangolin_classification, filter_geo_location, filter_usa_state, filter_complete_only, returned_content, table_fields, page_size, page_token, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus metadata by accession
    #'
    #' @param accessions genome sequence accessions
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param returned_content (optional) Return either virus genome accessions, or complete virus metadata
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsVirusDataReportPage) with additional information such as HTTP status code, headers
    VirusReportsByAcessionsWithHttpInfo = function(accessions, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, returned_content = NULL, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }















      query_params[["filter.refseq_only"]] <- `filter_refseq_only`

      query_params[["filter.annotated_only"]] <- `filter_annotated_only`

      query_params[["filter.released_since"]] <- `filter_released_since`

      query_params[["filter.updated_since"]] <- `filter_updated_since`

      query_params[["filter.host"]] <- `filter_host`

      query_params[["filter.pangolin_classification"]] <- `filter_pangolin_classification`

      query_params[["filter.geo_location"]] <- `filter_geo_location`

      query_params[["filter.usa_state"]] <- `filter_usa_state`

      query_params[["filter.complete_only"]] <- `filter_complete_only`

      query_params[["returned_content"]] <- `returned_content`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      local_var_url_path <- "/virus/accession/{accessions}/dataset_report"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsVirusDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus metadata by POST
    #'
    #' @param v2_virus_data_report_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsVirusDataReportPage
    VirusReportsByPost = function(v2_virus_data_report_request, data_file = NULL, ...) {
      local_var_response <- self$VirusReportsByPostWithHttpInfo(v2_virus_data_report_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus metadata by POST
    #'
    #' @param v2_virus_data_report_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsVirusDataReportPage) with additional information such as HTTP status code, headers
    VirusReportsByPostWithHttpInfo = function(v2_virus_data_report_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_virus_data_report_request`)) {
        stop("Missing required parameter `v2_virus_data_report_request`.")
      }


      if (!is.null(`v2_virus_data_report_request`)) {
        local_var_body <- `v2_virus_data_report_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/virus"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsVirusDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get virus metadata by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param returned_content (optional) Return either virus genome accessions, or complete virus metadata
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsVirusDataReportPage
    VirusReportsByTaxon = function(taxon, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, returned_content = NULL, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      local_var_response <- self$VirusReportsByTaxonWithHttpInfo(taxon, filter_refseq_only, filter_annotated_only, filter_released_since, filter_updated_since, filter_host, filter_pangolin_classification, filter_geo_location, filter_usa_state, filter_complete_only, returned_content, table_fields, page_size, page_token, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get virus metadata by taxon
    #'
    #' @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param filter_refseq_only (optional) If true, limit results to RefSeq genomes. (default value: FALSE)
    #' @param filter_annotated_only (optional) If true, limit results to annotated genomes. (default value: FALSE)
    #' @param filter_released_since (optional) If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as '2020-04-01T00:00:00.000Z'
    #' @param filter_updated_since (optional) No description
    #' @param filter_host (optional) If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
    #' @param filter_pangolin_classification (optional) If set, limit results to genomes classified to this lineage by the PangoLearn tool.
    #' @param filter_geo_location (optional) Assemblies from this location (country or continent)
    #' @param filter_usa_state (optional) Assemblies from this state (official two letter code only)
    #' @param filter_complete_only (optional) only include complete genomes. (default value: FALSE)
    #' @param returned_content (optional) Return either virus genome accessions, or complete virus metadata
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param page_size (optional) The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from a `GetVirusDataReports` call with more than `page_size` results. Use this token, along with the previous `VirusDataReportRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsVirusDataReportPage) with additional information such as HTTP status code, headers
    VirusReportsByTaxonWithHttpInfo = function(taxon, filter_refseq_only = FALSE, filter_annotated_only = FALSE, filter_released_since = NULL, filter_updated_since = NULL, filter_host = NULL, filter_pangolin_classification = NULL, filter_geo_location = NULL, filter_usa_state = NULL, filter_complete_only = FALSE, returned_content = NULL, table_fields = NULL, page_size = 20, page_token = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }















      query_params[["filter.refseq_only"]] <- `filter_refseq_only`

      query_params[["filter.annotated_only"]] <- `filter_annotated_only`

      query_params[["filter.released_since"]] <- `filter_released_since`

      query_params[["filter.updated_since"]] <- `filter_updated_since`

      query_params[["filter.host"]] <- `filter_host`

      query_params[["filter.pangolin_classification"]] <- `filter_pangolin_classification`

      query_params[["filter.geo_location"]] <- `filter_geo_location`

      query_params[["filter.usa_state"]] <- `filter_usa_state`

      query_params[["filter.complete_only"]] <- `filter_complete_only`

      query_params[["returned_content"]] <- `returned_content`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      local_var_url_path <- "/virus/taxon/{taxon}/dataset_report"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub("\\{taxon\\}", URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsVirusDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
