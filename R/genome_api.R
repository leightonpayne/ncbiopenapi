#' NCBI Datasets API
#'
#' ### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 2 API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated zip archive](https://www.ncbi.nlm.nih.gov/datasets/docs/v2/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 
#'
#' The version of the OpenAPI document: v2
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Genome operations
#' @description GenomeApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  AnnotationReportFacetsByAccession  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "GCF_000001635.27" # character | 
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#'
#' #Get genome annotation report summary information
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AnnotationReportFacetsByAccession(var_accession, sort_field = var_sort_field, sort_direction = var_sort_directiondata_file = "result.txt")
#' result <- api_instance$AnnotationReportFacetsByAccession(var_accession, sort_field = var_sort_field, sort_direction = var_sort_direction)
#' dput(result)
#'
#'
#' ####################  AnnotationReportFacetsByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_genome_annotation_request <- v2GenomeAnnotationRequest$new("accession_example", c("annotation_ids_example"), c("symbols_example"), c("locations_example"), c("gene_types_example"), c("search_text_example"), c(v2SortField$new("field_example", v2SortDirection$new())), c(v2GenomeAnnotationRequestAnnotationType$new()), 123, c("table_fields_example"), v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new(), v2IncludeTabularHeader$new(), "page_token_example") # V2GenomeAnnotationRequest | 
#'
#' #Get genome annotation report summary information
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AnnotationReportFacetsByPost(var_v2_genome_annotation_requestdata_file = "result.txt")
#' result <- api_instance$AnnotationReportFacetsByPost(var_v2_genome_annotation_request)
#' dput(result)
#'
#'
#' ####################  AssemblyAccessionsForSequenceAccession  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "NC_000001.11" # character | 
#'
#' #Get assembly accessions for a sequence accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssemblyAccessionsForSequenceAccession(var_accessiondata_file = "result.txt")
#' result <- api_instance$AssemblyAccessionsForSequenceAccession(var_accession)
#' dput(result)
#'
#'
#' ####################  AssemblyAccessionsForSequenceAccessionByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_sequence_accession_request <- v2SequenceAccessionRequest$new("accession_example") # V2SequenceAccessionRequest | 
#'
#' #Get assembly accessions for a sequence accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssemblyAccessionsForSequenceAccessionByPost(var_v2_sequence_accession_requestdata_file = "result.txt")
#' result <- api_instance$AssemblyAccessionsForSequenceAccessionByPost(var_v2_sequence_accession_request)
#' dput(result)
#'
#'
#' ####################  AssemblyRevisionHistoryByGet  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "GCF_000001405.40" # character | 
#'
#' #Get revision history for assembly by accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssemblyRevisionHistoryByGet(var_accessiondata_file = "result.txt")
#' result <- api_instance$AssemblyRevisionHistoryByGet(var_accession)
#' dput(result)
#'
#'
#' ####################  AssemblyRevisionHistoryByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_revision_history_request <- v2AssemblyRevisionHistoryRequest$new("accession_example") # V2AssemblyRevisionHistoryRequest | 
#'
#' #Get revision history for assembly by accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssemblyRevisionHistoryByPost(var_v2_assembly_revision_history_requestdata_file = "result.txt")
#' result <- api_instance$AssemblyRevisionHistoryByPost(var_v2_assembly_revision_history_request)
#' dput(result)
#'
#'
#' ####################  CheckAssemblyAvailability  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | NCBI genome assembly accessions
#'
#' #Check the validity of genome accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CheckAssemblyAvailability(var_accessionsdata_file = "result.txt")
#' result <- api_instance$CheckAssemblyAvailability(var_accessions)
#' dput(result)
#'
#'
#' ####################  CheckAssemblyAvailabilityPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_dataset_request <- v2AssemblyDatasetRequest$new(c("accessions_example"), c("chromosomes_example"), c(v2AnnotationForAssemblyType$new()), v2AssemblyDatasetRequestResolution$new(), "include_tsv_example") # V2AssemblyDatasetRequest | 
#'
#' #Check the validity of many genome accessions in a single request
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CheckAssemblyAvailabilityPost(var_v2_assembly_dataset_requestdata_file = "result.txt")
#' result <- api_instance$CheckAssemblyAvailabilityPost(var_v2_assembly_dataset_request)
#' dput(result)
#'
#'
#' ####################  CheckmHistogramByTaxon  ####################
#'
#' library(ncbiopenapi)
#' var_species_taxon <- "202956" # character | 
#'
#' #Get CheckM histogram by species taxon
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CheckmHistogramByTaxon(var_species_taxondata_file = "result.txt")
#' result <- api_instance$CheckmHistogramByTaxon(var_species_taxon)
#' dput(result)
#'
#'
#' ####################  CheckmHistogramByTaxonByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_check_m_histogram_request <- v2AssemblyCheckMHistogramRequest$new("species_taxon_example") # V2AssemblyCheckMHistogramRequest | 
#'
#' #Get CheckM histogram by species taxon
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CheckmHistogramByTaxonByPost(var_v2_assembly_check_m_histogram_requestdata_file = "result.txt")
#' result <- api_instance$CheckmHistogramByTaxonByPost(var_v2_assembly_check_m_histogram_request)
#' dput(result)
#'
#'
#' ####################  DownloadAssemblyPackage  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | NCBI genome assembly accessions
#' var_chromosomes <- c("inner_example") # array[character] | The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence. (Optional)
#' var_include_annotation_type <- c(v2AnnotationForAssemblyType$new()) # array[V2AnnotationForAssemblyType] | Select additional types of annotation to include in the data package.  If unset, no annotation is provided. (Optional)
#' var_hydrated <- v2AssemblyDatasetRequestResolution$new() # V2AssemblyDatasetRequestResolution | Set to DATA_REPORT_ONLY, to only retrieve data-reports. (Optional)
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Get a genome dataset by accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DownloadAssemblyPackage(var_accessions, chromosomes = var_chromosomes, include_annotation_type = var_include_annotation_type, hydrated = var_hydrated, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$DownloadAssemblyPackage(var_accessions, chromosomes = var_chromosomes, include_annotation_type = var_include_annotation_type, hydrated = var_hydrated, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  DownloadAssemblyPackagePost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_dataset_request <- v2AssemblyDatasetRequest$new(c("accessions_example"), c("chromosomes_example"), c(v2AnnotationForAssemblyType$new()), v2AssemblyDatasetRequestResolution$new(), "include_tsv_example") # V2AssemblyDatasetRequest | 
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Get a genome dataset by post
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DownloadAssemblyPackagePost(var_v2_assembly_dataset_request, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$DownloadAssemblyPackagePost(var_v2_assembly_dataset_request, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  DownloadGenomeAnnotationPackage  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "GCF_000001635.27" # character | 
#' var_annotation_ids <- c("inner_example") # array[character] | Limit the reports by internal, unstable annotation ids. (Optional)
#' var_symbols <- c("inner_example") # array[character] | Filter parameters (Optional)
#' var_locations <- c("inner_example") # array[character] | Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end] (Optional)
#' var_gene_types <- c("inner_example") # array[character] | granular gene_types (Optional)
#' var_search_text <- c("inner_example") # array[character] |  (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_annotation_type <- c(v2GenomeAnnotationRequestAnnotationType$new()) # array[V2GenomeAnnotationRequestAnnotationType] |  (Optional)
#' var_page_size <- 20 # integer | The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_table_format <- v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new() # V2GenomeAnnotationRequestGenomeAnnotationTableFormat | Optional pre-defined template for processing a tabular data request (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Get an annotation report dataset by accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DownloadGenomeAnnotationPackage(var_accession, annotation_ids = var_annotation_ids, symbols = var_symbols, locations = var_locations, gene_types = var_gene_types, search_text = var_search_text, sort_field = var_sort_field, sort_direction = var_sort_direction, include_annotation_type = var_include_annotation_type, page_size = var_page_size, table_fields = var_table_fields, table_format = var_table_format, include_tabular_header = var_include_tabular_header, page_token = var_page_token, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$DownloadGenomeAnnotationPackage(var_accession, annotation_ids = var_annotation_ids, symbols = var_symbols, locations = var_locations, gene_types = var_gene_types, search_text = var_search_text, sort_field = var_sort_field, sort_direction = var_sort_direction, include_annotation_type = var_include_annotation_type, page_size = var_page_size, table_fields = var_table_fields, table_format = var_table_format, include_tabular_header = var_include_tabular_header, page_token = var_page_token, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  DownloadGenomeAnnotationPackageByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_genome_annotation_request <- v2GenomeAnnotationRequest$new("accession_example", c("annotation_ids_example"), c("symbols_example"), c("locations_example"), c("gene_types_example"), c("search_text_example"), c(v2SortField$new("field_example", v2SortDirection$new())), c(v2GenomeAnnotationRequestAnnotationType$new()), 123, c("table_fields_example"), v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new(), v2IncludeTabularHeader$new(), "page_token_example") # V2GenomeAnnotationRequest | 
#' var_filename <- "ncbi_dataset.zip" # character | Output file name. (Optional)
#'
#' #Get an annotation report dataset by accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DownloadGenomeAnnotationPackageByPost(var_v2_genome_annotation_request, filename = var_filenamedata_file = "result.txt")
#' result <- api_instance$DownloadGenomeAnnotationPackageByPost(var_v2_genome_annotation_request, filename = var_filename)
#' dput(result)
#'
#'
#' ####################  GenomeAnnotationDownloadSummary  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "GCF_000001635.27" # character | 
#' var_annotation_ids <- c("inner_example") # array[character] | Limit the reports by internal, unstable annotation ids. (Optional)
#' var_symbols <- c("inner_example") # array[character] | Filter parameters (Optional)
#' var_locations <- c("inner_example") # array[character] | Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end] (Optional)
#' var_gene_types <- c("inner_example") # array[character] | granular gene_types (Optional)
#' var_search_text <- c("inner_example") # array[character] |  (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_annotation_type <- c(v2GenomeAnnotationRequestAnnotationType$new()) # array[V2GenomeAnnotationRequestAnnotationType] |  (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_table_format <- v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new() # V2GenomeAnnotationRequestGenomeAnnotationTableFormat | Optional pre-defined template for processing a tabular data request (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Preview feature dataset download
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeAnnotationDownloadSummary(var_accession, annotation_ids = var_annotation_ids, symbols = var_symbols, locations = var_locations, gene_types = var_gene_types, search_text = var_search_text, sort_field = var_sort_field, sort_direction = var_sort_direction, include_annotation_type = var_include_annotation_type, table_fields = var_table_fields, table_format = var_table_format, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeAnnotationDownloadSummary(var_accession, annotation_ids = var_annotation_ids, symbols = var_symbols, locations = var_locations, gene_types = var_gene_types, search_text = var_search_text, sort_field = var_sort_field, sort_direction = var_sort_direction, include_annotation_type = var_include_annotation_type, table_fields = var_table_fields, table_format = var_table_format, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeAnnotationDownloadSummaryByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_genome_annotation_request <- v2GenomeAnnotationRequest$new("accession_example", c("annotation_ids_example"), c("symbols_example"), c("locations_example"), c("gene_types_example"), c("search_text_example"), c(v2SortField$new("field_example", v2SortDirection$new())), c(v2GenomeAnnotationRequestAnnotationType$new()), 123, c("table_fields_example"), v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new(), v2IncludeTabularHeader$new(), "page_token_example") # V2GenomeAnnotationRequest | 
#'
#' #Preview feature download by POST
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeAnnotationDownloadSummaryByPost(var_v2_genome_annotation_requestdata_file = "result.txt")
#' result <- api_instance$GenomeAnnotationDownloadSummaryByPost(var_v2_genome_annotation_request)
#' dput(result)
#'
#'
#' ####################  GenomeAnnotationReport  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "GCF_000001635.27" # character | 
#' var_annotation_ids <- c("inner_example") # array[character] | Limit the reports by internal, unstable annotation ids. (Optional)
#' var_symbols <- c("inner_example") # array[character] | Filter parameters (Optional)
#' var_locations <- c("inner_example") # array[character] | Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end] (Optional)
#' var_gene_types <- c("inner_example") # array[character] | granular gene_types (Optional)
#' var_search_text <- c("inner_example") # array[character] |  (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_page_size <- 20 # integer | The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_table_fields <- c("inner_example") # array[character] | Specify which fields to include in the tabular report (Optional)
#' var_table_format <- v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new() # V2GenomeAnnotationRequestGenomeAnnotationTableFormat | Optional pre-defined template for processing a tabular data request (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#'
#' #Get genome annotation reports by genome accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeAnnotationReport(var_accession, annotation_ids = var_annotation_ids, symbols = var_symbols, locations = var_locations, gene_types = var_gene_types, search_text = var_search_text, sort_field = var_sort_field, sort_direction = var_sort_direction, page_size = var_page_size, table_fields = var_table_fields, table_format = var_table_format, include_tabular_header = var_include_tabular_header, page_token = var_page_tokendata_file = "result.txt")
#' result <- api_instance$GenomeAnnotationReport(var_accession, annotation_ids = var_annotation_ids, symbols = var_symbols, locations = var_locations, gene_types = var_gene_types, search_text = var_search_text, sort_field = var_sort_field, sort_direction = var_sort_direction, page_size = var_page_size, table_fields = var_table_fields, table_format = var_table_format, include_tabular_header = var_include_tabular_header, page_token = var_page_token)
#' dput(result)
#'
#'
#' ####################  GenomeAnnotationReportByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_genome_annotation_request <- v2GenomeAnnotationRequest$new("accession_example", c("annotation_ids_example"), c("symbols_example"), c("locations_example"), c("gene_types_example"), c("search_text_example"), c(v2SortField$new("field_example", v2SortDirection$new())), c(v2GenomeAnnotationRequestAnnotationType$new()), 123, c("table_fields_example"), v2GenomeAnnotationRequestGenomeAnnotationTableFormat$new(), v2IncludeTabularHeader$new(), "page_token_example") # V2GenomeAnnotationRequest | 
#'
#' #Get genome annotation reports by genome accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeAnnotationReportByPost(var_v2_genome_annotation_requestdata_file = "result.txt")
#' result <- api_instance$GenomeAnnotationReportByPost(var_v2_genome_annotation_request)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReport  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | 
#' var_filters_reference_only <- FALSE # character | If true, only return reference genome assemblies (Optional)
#' var_filters_assembly_source <- v2AssemblyDatasetDescriptorsFilterAssemblySource$new() # V2AssemblyDatasetDescriptorsFilterAssemblySource | Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies (Optional)
#' var_filters_has_annotation <- FALSE # character | Return only annotated genome assemblies (Optional)
#' var_filters_exclude_paired_reports <- FALSE # character | For paired (GCA/GCF) records, only return the primary record (Optional)
#' var_filters_exclude_atypical <- FALSE # character | If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (Optional)
#' var_filters_assembly_version <- v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new() # V2AssemblyDatasetDescriptorsFilterAssemblyVersion | Return all assemblies, including replaced and suppressed, or only current assemblies (Optional)
#' var_filters_assembly_level <- c(v2reportsAssemblyLevel$new()) # array[V2reportsAssemblyLevel] | Only return genome assemblies that have one of the specified assembly levels. By default, do not filter. (Optional)
#' var_filters_first_release_date <- "2015-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or after the specified date By default, do not filter. (Optional)
#' var_filters_last_release_date <- "2021-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or before to the specified date By default, do not filter. (Optional)
#' var_filters_search_text <- c("inner_example") # array[character] | Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter (Optional)
#' var_filters_is_metagenome_derived <- v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new() # V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter |  (Optional)
#' var_filters_is_type_material <- FALSE # character | If true, include only type materials (Optional)
#' var_filters_is_ictv_exemplar <- FALSE # character | If true, include only ICTV Exemplars (Optional)
#' var_filters_exclude_multi_isolate <- FALSE # character | If true, exclude large multi-isolate projects (Optional)
#' var_filters_type_material_category <- v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new() # V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory |  (Optional)
#' var_tax_exact_match <- FALSE # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_returned_content <- v2AssemblyDatasetReportsRequestContentType$new() # V2AssemblyDatasetReportsRequestContentType | Return either assembly accessions, or complete assembly reports (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Get dataset reports by accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReport(var_accessions, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReport(var_accessions, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReportByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_dataset_reports_request <- v2AssemblyDatasetReportsRequest$new(c("taxons_example"), c("bioprojects_example"), c("biosample_ids_example"), c("assembly_names_example"), c("wgs_accessions_example"), c("accessions_example"), v2AssemblyDatasetDescriptorsFilter$new("reference_only_example", v2AssemblyDatasetDescriptorsFilterAssemblySource$new(), "has_annotation_example", "exclude_paired_reports_example", "exclude_atypical_example", v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new(), c(v2reportsAssemblyLevel$new()), "first_release_date_example", "last_release_date_example", c("search_text_example"), v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new(), "is_type_material_example", "is_ictv_exemplar_example", "exclude_multi_isolate_example", v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new()), "tax_exact_match_example", c("chromosomes_example"), c("table_fields_example"), v2AssemblyDatasetReportsRequestContentType$new(), 123, "page_token_example", c(v2SortField$new("field_example", v2SortDirection$new())), v2IncludeTabularHeader$new(), "table_format_example") # V2AssemblyDatasetReportsRequest | 
#'
#' #Get dataset reports by accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReportByPost(var_v2_assembly_dataset_reports_requestdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReportByPost(var_v2_assembly_dataset_reports_request)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReportsByAssemblyName  ####################
#'
#' library(ncbiopenapi)
#' var_assembly_names <- c("inner_example") # array[character] | 
#' var_filters_reference_only <- FALSE # character | If true, only return reference genome assemblies (Optional)
#' var_filters_assembly_source <- v2AssemblyDatasetDescriptorsFilterAssemblySource$new() # V2AssemblyDatasetDescriptorsFilterAssemblySource | Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies (Optional)
#' var_filters_has_annotation <- FALSE # character | Return only annotated genome assemblies (Optional)
#' var_filters_exclude_paired_reports <- FALSE # character | For paired (GCA/GCF) records, only return the primary record (Optional)
#' var_filters_exclude_atypical <- FALSE # character | If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (Optional)
#' var_filters_assembly_version <- v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new() # V2AssemblyDatasetDescriptorsFilterAssemblyVersion | Return all assemblies, including replaced and suppressed, or only current assemblies (Optional)
#' var_filters_assembly_level <- c(v2reportsAssemblyLevel$new()) # array[V2reportsAssemblyLevel] | Only return genome assemblies that have one of the specified assembly levels. By default, do not filter. (Optional)
#' var_filters_first_release_date <- "2015-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or after the specified date By default, do not filter. (Optional)
#' var_filters_last_release_date <- "2021-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or before to the specified date By default, do not filter. (Optional)
#' var_filters_search_text <- c("inner_example") # array[character] | Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter (Optional)
#' var_filters_is_metagenome_derived <- v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new() # V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter |  (Optional)
#' var_filters_is_type_material <- FALSE # character | If true, include only type materials (Optional)
#' var_filters_is_ictv_exemplar <- FALSE # character | If true, include only ICTV Exemplars (Optional)
#' var_filters_exclude_multi_isolate <- FALSE # character | If true, exclude large multi-isolate projects (Optional)
#' var_filters_type_material_category <- v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new() # V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory |  (Optional)
#' var_tax_exact_match <- FALSE # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_returned_content <- v2AssemblyDatasetReportsRequestContentType$new() # V2AssemblyDatasetReportsRequestContentType | Return either assembly accessions, or complete assembly reports (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Get dataset reports by assembly name (exact)
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReportsByAssemblyName(var_assembly_names, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReportsByAssemblyName(var_assembly_names, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReportsByBioproject  ####################
#'
#' library(ncbiopenapi)
#' var_bioprojects <- c("inner_example") # array[character] | 
#' var_filters_reference_only <- FALSE # character | If true, only return reference genome assemblies (Optional)
#' var_filters_assembly_source <- v2AssemblyDatasetDescriptorsFilterAssemblySource$new() # V2AssemblyDatasetDescriptorsFilterAssemblySource | Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies (Optional)
#' var_filters_has_annotation <- FALSE # character | Return only annotated genome assemblies (Optional)
#' var_filters_exclude_paired_reports <- FALSE # character | For paired (GCA/GCF) records, only return the primary record (Optional)
#' var_filters_exclude_atypical <- FALSE # character | If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (Optional)
#' var_filters_assembly_version <- v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new() # V2AssemblyDatasetDescriptorsFilterAssemblyVersion | Return all assemblies, including replaced and suppressed, or only current assemblies (Optional)
#' var_filters_assembly_level <- c(v2reportsAssemblyLevel$new()) # array[V2reportsAssemblyLevel] | Only return genome assemblies that have one of the specified assembly levels. By default, do not filter. (Optional)
#' var_filters_first_release_date <- "2015-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or after the specified date By default, do not filter. (Optional)
#' var_filters_last_release_date <- "2021-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or before to the specified date By default, do not filter. (Optional)
#' var_filters_search_text <- c("inner_example") # array[character] | Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter (Optional)
#' var_filters_is_metagenome_derived <- v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new() # V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter |  (Optional)
#' var_filters_is_type_material <- FALSE # character | If true, include only type materials (Optional)
#' var_filters_is_ictv_exemplar <- FALSE # character | If true, include only ICTV Exemplars (Optional)
#' var_filters_exclude_multi_isolate <- FALSE # character | If true, exclude large multi-isolate projects (Optional)
#' var_filters_type_material_category <- v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new() # V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory |  (Optional)
#' var_tax_exact_match <- FALSE # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_returned_content <- v2AssemblyDatasetReportsRequestContentType$new() # V2AssemblyDatasetReportsRequestContentType | Return either assembly accessions, or complete assembly reports (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Get dataset reports by bioproject
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReportsByBioproject(var_bioprojects, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReportsByBioproject(var_bioprojects, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReportsByBiosampleId  ####################
#'
#' library(ncbiopenapi)
#' var_biosample_ids <- c("inner_example") # array[character] | 
#' var_filters_reference_only <- FALSE # character | If true, only return reference genome assemblies (Optional)
#' var_filters_assembly_source <- v2AssemblyDatasetDescriptorsFilterAssemblySource$new() # V2AssemblyDatasetDescriptorsFilterAssemblySource | Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies (Optional)
#' var_filters_has_annotation <- FALSE # character | Return only annotated genome assemblies (Optional)
#' var_filters_exclude_paired_reports <- FALSE # character | For paired (GCA/GCF) records, only return the primary record (Optional)
#' var_filters_exclude_atypical <- FALSE # character | If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (Optional)
#' var_filters_assembly_version <- v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new() # V2AssemblyDatasetDescriptorsFilterAssemblyVersion | Return all assemblies, including replaced and suppressed, or only current assemblies (Optional)
#' var_filters_assembly_level <- c(v2reportsAssemblyLevel$new()) # array[V2reportsAssemblyLevel] | Only return genome assemblies that have one of the specified assembly levels. By default, do not filter. (Optional)
#' var_filters_first_release_date <- "2015-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or after the specified date By default, do not filter. (Optional)
#' var_filters_last_release_date <- "2021-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or before to the specified date By default, do not filter. (Optional)
#' var_filters_search_text <- c("inner_example") # array[character] | Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter (Optional)
#' var_filters_is_metagenome_derived <- v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new() # V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter |  (Optional)
#' var_filters_is_type_material <- FALSE # character | If true, include only type materials (Optional)
#' var_filters_is_ictv_exemplar <- FALSE # character | If true, include only ICTV Exemplars (Optional)
#' var_filters_exclude_multi_isolate <- FALSE # character | If true, exclude large multi-isolate projects (Optional)
#' var_filters_type_material_category <- v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new() # V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory |  (Optional)
#' var_tax_exact_match <- FALSE # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_returned_content <- v2AssemblyDatasetReportsRequestContentType$new() # V2AssemblyDatasetReportsRequestContentType | Return either assembly accessions, or complete assembly reports (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Get dataset reports by biosample id
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReportsByBiosampleId(var_biosample_ids, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReportsByBiosampleId(var_biosample_ids, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReportsByTaxon  ####################
#'
#' library(ncbiopenapi)
#' var_taxons <- c("inner_example") # array[character] | NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
#' var_filters_reference_only <- FALSE # character | If true, only return reference genome assemblies (Optional)
#' var_filters_assembly_source <- v2AssemblyDatasetDescriptorsFilterAssemblySource$new() # V2AssemblyDatasetDescriptorsFilterAssemblySource | Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies (Optional)
#' var_filters_has_annotation <- FALSE # character | Return only annotated genome assemblies (Optional)
#' var_filters_exclude_paired_reports <- FALSE # character | For paired (GCA/GCF) records, only return the primary record (Optional)
#' var_filters_exclude_atypical <- FALSE # character | If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (Optional)
#' var_filters_assembly_version <- v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new() # V2AssemblyDatasetDescriptorsFilterAssemblyVersion | Return all assemblies, including replaced and suppressed, or only current assemblies (Optional)
#' var_filters_assembly_level <- c(v2reportsAssemblyLevel$new()) # array[V2reportsAssemblyLevel] | Only return genome assemblies that have one of the specified assembly levels. By default, do not filter. (Optional)
#' var_filters_first_release_date <- "2015-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or after the specified date By default, do not filter. (Optional)
#' var_filters_last_release_date <- "2021-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or before to the specified date By default, do not filter. (Optional)
#' var_filters_search_text <- c("inner_example") # array[character] | Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter (Optional)
#' var_filters_is_metagenome_derived <- v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new() # V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter |  (Optional)
#' var_filters_is_type_material <- FALSE # character | If true, include only type materials (Optional)
#' var_filters_is_ictv_exemplar <- FALSE # character | If true, include only ICTV Exemplars (Optional)
#' var_filters_exclude_multi_isolate <- FALSE # character | If true, exclude large multi-isolate projects (Optional)
#' var_filters_type_material_category <- v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new() # V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory |  (Optional)
#' var_tax_exact_match <- FALSE # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_returned_content <- v2AssemblyDatasetReportsRequestContentType$new() # V2AssemblyDatasetReportsRequestContentType | Return either assembly accessions, or complete assembly reports (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Get dataset reports by taxons
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReportsByTaxon(var_taxons, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReportsByTaxon(var_taxons, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeDatasetReportsByWgs  ####################
#'
#' library(ncbiopenapi)
#' var_wgs_accessions <- c("inner_example") # array[character] | 
#' var_filters_reference_only <- FALSE # character | If true, only return reference genome assemblies (Optional)
#' var_filters_assembly_source <- v2AssemblyDatasetDescriptorsFilterAssemblySource$new() # V2AssemblyDatasetDescriptorsFilterAssemblySource | Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies (Optional)
#' var_filters_has_annotation <- FALSE # character | Return only annotated genome assemblies (Optional)
#' var_filters_exclude_paired_reports <- FALSE # character | For paired (GCA/GCF) records, only return the primary record (Optional)
#' var_filters_exclude_atypical <- FALSE # character | If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (Optional)
#' var_filters_assembly_version <- v2AssemblyDatasetDescriptorsFilterAssemblyVersion$new() # V2AssemblyDatasetDescriptorsFilterAssemblyVersion | Return all assemblies, including replaced and suppressed, or only current assemblies (Optional)
#' var_filters_assembly_level <- c(v2reportsAssemblyLevel$new()) # array[V2reportsAssemblyLevel] | Only return genome assemblies that have one of the specified assembly levels. By default, do not filter. (Optional)
#' var_filters_first_release_date <- "2015-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or after the specified date By default, do not filter. (Optional)
#' var_filters_last_release_date <- "2021-01-10T00:00:00Z" # character | Only return genome assemblies that were released on or before to the specified date By default, do not filter. (Optional)
#' var_filters_search_text <- c("inner_example") # array[character] | Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter (Optional)
#' var_filters_is_metagenome_derived <- v2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter$new() # V2AssemblyDatasetDescriptorsFilterMetagenomeDerivedFilter |  (Optional)
#' var_filters_is_type_material <- FALSE # character | If true, include only type materials (Optional)
#' var_filters_is_ictv_exemplar <- FALSE # character | If true, include only ICTV Exemplars (Optional)
#' var_filters_exclude_multi_isolate <- FALSE # character | If true, exclude large multi-isolate projects (Optional)
#' var_filters_type_material_category <- v2AssemblyDatasetDescriptorsFilterTypeMaterialCategory$new() # V2AssemblyDatasetDescriptorsFilterTypeMaterialCategory |  (Optional)
#' var_tax_exact_match <- FALSE # character | If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_returned_content <- v2AssemblyDatasetReportsRequestContentType$new() # V2AssemblyDatasetReportsRequestContentType | Return either assembly accessions, or complete assembly reports (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_sort_field <- "sort_field_example" # character |  (Optional)
#' var_sort_direction <- v2SortDirection$new() # V2SortDirection |  (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader | Whether this request for tabular data should include the header row (Optional)
#'
#' #Get dataset reports by wgs accession
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDatasetReportsByWgs(var_wgs_accessions, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeDatasetReportsByWgs(var_wgs_accessions, filters_reference_only = var_filters_reference_only, filters_assembly_source = var_filters_assembly_source, filters_has_annotation = var_filters_has_annotation, filters_exclude_paired_reports = var_filters_exclude_paired_reports, filters_exclude_atypical = var_filters_exclude_atypical, filters_assembly_version = var_filters_assembly_version, filters_assembly_level = var_filters_assembly_level, filters_first_release_date = var_filters_first_release_date, filters_last_release_date = var_filters_last_release_date, filters_search_text = var_filters_search_text, filters_is_metagenome_derived = var_filters_is_metagenome_derived, filters_is_type_material = var_filters_is_type_material, filters_is_ictv_exemplar = var_filters_is_ictv_exemplar, filters_exclude_multi_isolate = var_filters_exclude_multi_isolate, filters_type_material_category = var_filters_type_material_category, tax_exact_match = var_tax_exact_match, table_fields = var_table_fields, returned_content = var_returned_content, page_size = var_page_size, page_token = var_page_token, sort_field = var_sort_field, sort_direction = var_sort_direction, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeDownloadSummary  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | NCBI genome assembly accessions
#' var_chromosomes <- c("inner_example") # array[character] | The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence. (Optional)
#' var_include_annotation_type <- c(v2AnnotationForAssemblyType$new()) # array[V2AnnotationForAssemblyType] | Select additional types of annotation to include in the data package.  If unset, no annotation is provided. (Optional)
#'
#' #Preview genome dataset download
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDownloadSummary(var_accessions, chromosomes = var_chromosomes, include_annotation_type = var_include_annotation_typedata_file = "result.txt")
#' result <- api_instance$GenomeDownloadSummary(var_accessions, chromosomes = var_chromosomes, include_annotation_type = var_include_annotation_type)
#' dput(result)
#'
#'
#' ####################  GenomeDownloadSummaryByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_dataset_request <- v2AssemblyDatasetRequest$new(c("accessions_example"), c("chromosomes_example"), c(v2AnnotationForAssemblyType$new()), v2AssemblyDatasetRequestResolution$new(), "include_tsv_example") # V2AssemblyDatasetRequest | 
#'
#' #Preview genome dataset download by POST
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeDownloadSummaryByPost(var_v2_assembly_dataset_requestdata_file = "result.txt")
#' result <- api_instance$GenomeDownloadSummaryByPost(var_v2_assembly_dataset_request)
#' dput(result)
#'
#'
#' ####################  GenomeLinksByAccession  ####################
#'
#' library(ncbiopenapi)
#' var_accessions <- c("inner_example") # array[character] | NCBI genome assembly accessions, limited to 1000
#'
#' #Get assembly links by accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeLinksByAccession(var_accessionsdata_file = "result.txt")
#' result <- api_instance$GenomeLinksByAccession(var_accessions)
#' dput(result)
#'
#'
#' ####################  GenomeLinksByAccessionByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_links_request <- v2AssemblyLinksRequest$new(c("accessions_example")) # V2AssemblyLinksRequest | 
#'
#' #Get assembly links by accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeLinksByAccessionByPost(var_v2_assembly_links_requestdata_file = "result.txt")
#' result <- api_instance$GenomeLinksByAccessionByPost(var_v2_assembly_links_request)
#' dput(result)
#'
#'
#' ####################  GenomeSequenceReport  ####################
#'
#' library(ncbiopenapi)
#' var_accession <- "GCF_000001635.27" # character | 
#' var_chromosomes <- c("inner_example") # array[character] |  (Optional)
#' var_role_filters <- c("inner_example") # array[character] |  (Optional)
#' var_table_fields <- c("inner_example") # array[character] |  (Optional)
#' var_count_assembly_unplaced <- FALSE # character |  (Optional)
#' var_page_size <- 20 # integer | The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (Optional)
#' var_page_token <- "page_token_example" # character | A page token is returned from an `GetSequenceReports` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved. (Optional)
#' var_include_tabular_header <- v2IncludeTabularHeader$new() # V2IncludeTabularHeader |  (Optional)
#'
#' #Get sequence reports by accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeSequenceReport(var_accession, chromosomes = var_chromosomes, role_filters = var_role_filters, table_fields = var_table_fields, count_assembly_unplaced = var_count_assembly_unplaced, page_size = var_page_size, page_token = var_page_token, include_tabular_header = var_include_tabular_headerdata_file = "result.txt")
#' result <- api_instance$GenomeSequenceReport(var_accession, chromosomes = var_chromosomes, role_filters = var_role_filters, table_fields = var_table_fields, count_assembly_unplaced = var_count_assembly_unplaced, page_size = var_page_size, page_token = var_page_token, include_tabular_header = var_include_tabular_header)
#' dput(result)
#'
#'
#' ####################  GenomeSequenceReportByPost  ####################
#'
#' library(ncbiopenapi)
#' var_v2_assembly_sequence_reports_request <- v2AssemblySequenceReportsRequest$new("accession_example", c("chromosomes_example"), c("role_filters_example"), c("table_fields_example"), "count_assembly_unplaced_example", 123, "page_token_example", v2IncludeTabularHeader$new(), "table_format_example") # V2AssemblySequenceReportsRequest | 
#'
#' #Get sequence reports by accessions
#' api_instance <- GenomeApi$new()
#'
#' # Configure API key authorization: ApiKeyAuthHeader
#' api_instance$api_client$api_keys["api-key"] <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GenomeSequenceReportByPost(var_v2_assembly_sequence_reports_requestdata_file = "result.txt")
#' result <- api_instance$GenomeSequenceReportByPost(var_v2_assembly_sequence_reports_request)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
GenomeApi <- R6::R6Class(
  "GenomeApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new GenomeApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Get genome annotation report summary information
    #'
    #' @param accession 
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2GenomeAnnotationTableSummaryReply
    AnnotationReportFacetsByAccession = function(accession, sort_field = NULL, sort_direction = NULL, data_file = NULL, ...) {
      local_var_response <- self$AnnotationReportFacetsByAccessionWithHttpInfo(accession, sort_field, sort_direction, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get genome annotation report summary information
    #'
    #' @param accession 
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2GenomeAnnotationTableSummaryReply) with additional information such as HTTP status code, headers
    AnnotationReportFacetsByAccessionWithHttpInfo = function(accession, sort_field = NULL, sort_direction = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }




      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      local_var_url_path <- "/genome/accession/{accession}/annotation_summary"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2GenomeAnnotationTableSummaryReply"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get genome annotation report summary information
    #'
    #' @param v2_genome_annotation_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2GenomeAnnotationTableSummaryReply
    AnnotationReportFacetsByPost = function(v2_genome_annotation_request, data_file = NULL, ...) {
      local_var_response <- self$AnnotationReportFacetsByPostWithHttpInfo(v2_genome_annotation_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get genome annotation report summary information
    #'
    #' @param v2_genome_annotation_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2GenomeAnnotationTableSummaryReply) with additional information such as HTTP status code, headers
    AnnotationReportFacetsByPostWithHttpInfo = function(v2_genome_annotation_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_genome_annotation_request`)) {
        stop("Missing required parameter `v2_genome_annotation_request`.")
      }


      if (!is.null(`v2_genome_annotation_request`)) {
        local_var_body <- `v2_genome_annotation_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/annotation_summary"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2GenomeAnnotationTableSummaryReply"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get assembly accessions for a sequence accession
    #'
    #' @param accession 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyAccessions
    AssemblyAccessionsForSequenceAccession = function(accession, data_file = NULL, ...) {
      local_var_response <- self$AssemblyAccessionsForSequenceAccessionWithHttpInfo(accession, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get assembly accessions for a sequence accession
    #'
    #' @param accession 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyAccessions) with additional information such as HTTP status code, headers
    AssemblyAccessionsForSequenceAccessionWithHttpInfo = function(accession, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }


      local_var_url_path <- "/genome/sequence_accession/{accession}/sequence_assemblies"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyAccessions"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get assembly accessions for a sequence accession
    #'
    #' @param v2_sequence_accession_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyAccessions
    AssemblyAccessionsForSequenceAccessionByPost = function(v2_sequence_accession_request, data_file = NULL, ...) {
      local_var_response <- self$AssemblyAccessionsForSequenceAccessionByPostWithHttpInfo(v2_sequence_accession_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get assembly accessions for a sequence accession
    #'
    #' @param v2_sequence_accession_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyAccessions) with additional information such as HTTP status code, headers
    AssemblyAccessionsForSequenceAccessionByPostWithHttpInfo = function(v2_sequence_accession_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_sequence_accession_request`)) {
        stop("Missing required parameter `v2_sequence_accession_request`.")
      }


      if (!is.null(`v2_sequence_accession_request`)) {
        local_var_body <- `v2_sequence_accession_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/sequence_assemblies"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyAccessions"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get revision history for assembly by accession
    #'
    #' @param accession 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyRevisionHistory
    AssemblyRevisionHistoryByGet = function(accession, data_file = NULL, ...) {
      local_var_response <- self$AssemblyRevisionHistoryByGetWithHttpInfo(accession, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get revision history for assembly by accession
    #'
    #' @param accession 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyRevisionHistory) with additional information such as HTTP status code, headers
    AssemblyRevisionHistoryByGetWithHttpInfo = function(accession, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }


      local_var_url_path <- "/genome/accession/{accession}/revision_history"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyRevisionHistory"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get revision history for assembly by accession
    #'
    #' @param v2_assembly_revision_history_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyRevisionHistory
    AssemblyRevisionHistoryByPost = function(v2_assembly_revision_history_request, data_file = NULL, ...) {
      local_var_response <- self$AssemblyRevisionHistoryByPostWithHttpInfo(v2_assembly_revision_history_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get revision history for assembly by accession
    #'
    #' @param v2_assembly_revision_history_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyRevisionHistory) with additional information such as HTTP status code, headers
    AssemblyRevisionHistoryByPostWithHttpInfo = function(v2_assembly_revision_history_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_revision_history_request`)) {
        stop("Missing required parameter `v2_assembly_revision_history_request`.")
      }


      if (!is.null(`v2_assembly_revision_history_request`)) {
        local_var_body <- `v2_assembly_revision_history_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/revision_history"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyRevisionHistory"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Check the validity of genome accessions
    #'
    #' @param accessions NCBI genome assembly accessions
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyDatasetAvailability
    CheckAssemblyAvailability = function(accessions, data_file = NULL, ...) {
      local_var_response <- self$CheckAssemblyAvailabilityWithHttpInfo(accessions, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Check the validity of genome accessions
    #'
    #' @param accessions NCBI genome assembly accessions
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyDatasetAvailability) with additional information such as HTTP status code, headers
    CheckAssemblyAvailabilityWithHttpInfo = function(accessions, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }


      local_var_url_path <- "/genome/accession/{accessions}/check"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyDatasetAvailability"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Check the validity of many genome accessions in a single request
    #'
    #' @param v2_assembly_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyDatasetAvailability
    CheckAssemblyAvailabilityPost = function(v2_assembly_dataset_request, data_file = NULL, ...) {
      local_var_response <- self$CheckAssemblyAvailabilityPostWithHttpInfo(v2_assembly_dataset_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Check the validity of many genome accessions in a single request
    #'
    #' @param v2_assembly_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyDatasetAvailability) with additional information such as HTTP status code, headers
    CheckAssemblyAvailabilityPostWithHttpInfo = function(v2_assembly_dataset_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_dataset_request`)) {
        stop("Missing required parameter `v2_assembly_dataset_request`.")
      }


      if (!is.null(`v2_assembly_dataset_request`)) {
        local_var_body <- `v2_assembly_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/check"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyDatasetAvailability"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get CheckM histogram by species taxon
    #'
    #' @param species_taxon 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyCheckMHistogramReply
    CheckmHistogramByTaxon = function(species_taxon, data_file = NULL, ...) {
      local_var_response <- self$CheckmHistogramByTaxonWithHttpInfo(species_taxon, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get CheckM histogram by species taxon
    #'
    #' @param species_taxon 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyCheckMHistogramReply) with additional information such as HTTP status code, headers
    CheckmHistogramByTaxonWithHttpInfo = function(species_taxon, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`species_taxon`)) {
        stop("Missing required parameter `species_taxon`.")
      }


      local_var_url_path <- "/genome/taxon/{species_taxon}/checkm_histogram"
      if (!missing(`species_taxon`)) {
        local_var_url_path <- gsub("\\{species_taxon\\}", URLencode(as.character(`species_taxon`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyCheckMHistogramReply"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get CheckM histogram by species taxon
    #'
    #' @param v2_assembly_check_m_histogram_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyCheckMHistogramReply
    CheckmHistogramByTaxonByPost = function(v2_assembly_check_m_histogram_request, data_file = NULL, ...) {
      local_var_response <- self$CheckmHistogramByTaxonByPostWithHttpInfo(v2_assembly_check_m_histogram_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get CheckM histogram by species taxon
    #'
    #' @param v2_assembly_check_m_histogram_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyCheckMHistogramReply) with additional information such as HTTP status code, headers
    CheckmHistogramByTaxonByPostWithHttpInfo = function(v2_assembly_check_m_histogram_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_check_m_histogram_request`)) {
        stop("Missing required parameter `v2_assembly_check_m_histogram_request`.")
      }


      if (!is.null(`v2_assembly_check_m_histogram_request`)) {
        local_var_body <- `v2_assembly_check_m_histogram_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/checkm_histogram"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyCheckMHistogramReply"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get a genome dataset by accession
    #'
    #' @param accessions NCBI genome assembly accessions
    #' @param chromosomes (optional) The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
    #' @param include_annotation_type (optional) Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
    #' @param hydrated (optional) Set to DATA_REPORT_ONLY, to only retrieve data-reports.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    DownloadAssemblyPackage = function(accessions, chromosomes = NULL, include_annotation_type = NULL, hydrated = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$DownloadAssemblyPackageWithHttpInfo(accessions, chromosomes, include_annotation_type, hydrated, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get a genome dataset by accession
    #'
    #' @param accessions NCBI genome assembly accessions
    #' @param chromosomes (optional) The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
    #' @param include_annotation_type (optional) Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
    #' @param hydrated (optional) Set to DATA_REPORT_ONLY, to only retrieve data-reports.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    DownloadAssemblyPackageWithHttpInfo = function(accessions, chromosomes = NULL, include_annotation_type = NULL, hydrated = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }






      # explore
      for (query_item in `chromosomes`) {
        query_params[["chromosomes"]] <- c(query_params[["chromosomes"]], list(`chromosomes` = query_item))
      }

      # explore
      for (query_item in `include_annotation_type`) {
        query_params[["include_annotation_type"]] <- c(query_params[["include_annotation_type"]], list(`include_annotation_type` = query_item))
      }

      query_params[["hydrated"]] <- `hydrated`

      query_params[["filename"]] <- `filename`

      local_var_url_path <- "/genome/accession/{accessions}/download"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get a genome dataset by post
    #'
    #' @param v2_assembly_dataset_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    DownloadAssemblyPackagePost = function(v2_assembly_dataset_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$DownloadAssemblyPackagePostWithHttpInfo(v2_assembly_dataset_request, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get a genome dataset by post
    #'
    #' @param v2_assembly_dataset_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    DownloadAssemblyPackagePostWithHttpInfo = function(v2_assembly_dataset_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_dataset_request`)) {
        stop("Missing required parameter `v2_assembly_dataset_request`.")
      }



      query_params[["filename"]] <- `filename`

      if (!is.null(`v2_assembly_dataset_request`)) {
        local_var_body <- `v2_assembly_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/download"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get an annotation report dataset by accession
    #'
    #' @param accession 
    #' @param annotation_ids (optional) Limit the reports by internal, unstable annotation ids.
    #' @param symbols (optional) Filter parameters
    #' @param locations (optional) Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
    #' @param gene_types (optional) granular gene_types
    #' @param search_text (optional) No description
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_annotation_type (optional) No description
    #' @param page_size (optional) The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param table_format (optional) Optional pre-defined template for processing a tabular data request
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param page_token (optional) A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    DownloadGenomeAnnotationPackage = function(accession, annotation_ids = NULL, symbols = NULL, locations = NULL, gene_types = NULL, search_text = NULL, sort_field = NULL, sort_direction = NULL, include_annotation_type = NULL, page_size = 20, table_fields = NULL, table_format = NULL, include_tabular_header = NULL, page_token = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$DownloadGenomeAnnotationPackageWithHttpInfo(accession, annotation_ids, symbols, locations, gene_types, search_text, sort_field, sort_direction, include_annotation_type, page_size, table_fields, table_format, include_tabular_header, page_token, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get an annotation report dataset by accession
    #'
    #' @param accession 
    #' @param annotation_ids (optional) Limit the reports by internal, unstable annotation ids.
    #' @param symbols (optional) Filter parameters
    #' @param locations (optional) Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
    #' @param gene_types (optional) granular gene_types
    #' @param search_text (optional) No description
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_annotation_type (optional) No description
    #' @param page_size (optional) The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param table_format (optional) Optional pre-defined template for processing a tabular data request
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param page_token (optional) A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    DownloadGenomeAnnotationPackageWithHttpInfo = function(accession, annotation_ids = NULL, symbols = NULL, locations = NULL, gene_types = NULL, search_text = NULL, sort_field = NULL, sort_direction = NULL, include_annotation_type = NULL, page_size = 20, table_fields = NULL, table_format = NULL, include_tabular_header = NULL, page_token = NULL, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }
















      # explore
      for (query_item in `annotation_ids`) {
        query_params[["annotation_ids"]] <- c(query_params[["annotation_ids"]], list(`annotation_ids` = query_item))
      }

      # explore
      for (query_item in `symbols`) {
        query_params[["symbols"]] <- c(query_params[["symbols"]], list(`symbols` = query_item))
      }

      # explore
      for (query_item in `locations`) {
        query_params[["locations"]] <- c(query_params[["locations"]], list(`locations` = query_item))
      }

      # explore
      for (query_item in `gene_types`) {
        query_params[["gene_types"]] <- c(query_params[["gene_types"]], list(`gene_types` = query_item))
      }

      # explore
      for (query_item in `search_text`) {
        query_params[["search_text"]] <- c(query_params[["search_text"]], list(`search_text` = query_item))
      }

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      # explore
      for (query_item in `include_annotation_type`) {
        query_params[["include_annotation_type"]] <- c(query_params[["include_annotation_type"]], list(`include_annotation_type` = query_item))
      }

      query_params[["page_size"]] <- `page_size`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["table_format"]] <- `table_format`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      query_params[["page_token"]] <- `page_token`

      query_params[["filename"]] <- `filename`

      local_var_url_path <- "/genome/accession/{accession}/annotation_report/download"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get an annotation report dataset by accession
    #'
    #' @param v2_genome_annotation_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    DownloadGenomeAnnotationPackageByPost = function(v2_genome_annotation_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      local_var_response <- self$DownloadGenomeAnnotationPackageByPostWithHttpInfo(v2_genome_annotation_request, filename, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get an annotation report dataset by accession
    #'
    #' @param v2_genome_annotation_request 
    #' @param filename (optional) Output file name. (default value: "ncbi_dataset.zip")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    DownloadGenomeAnnotationPackageByPostWithHttpInfo = function(v2_genome_annotation_request, filename = "ncbi_dataset.zip", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_genome_annotation_request`)) {
        stop("Missing required parameter `v2_genome_annotation_request`.")
      }



      query_params[["filename"]] <- `filename`

      if (!is.null(`v2_genome_annotation_request`)) {
        local_var_body <- `v2_genome_annotation_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/annotation_report/download"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/zip")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Preview feature dataset download
    #'
    #' @param accession 
    #' @param annotation_ids (optional) Limit the reports by internal, unstable annotation ids.
    #' @param symbols (optional) Filter parameters
    #' @param locations (optional) Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
    #' @param gene_types (optional) granular gene_types
    #' @param search_text (optional) No description
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_annotation_type (optional) No description
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param table_format (optional) Optional pre-defined template for processing a tabular data request
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    GenomeAnnotationDownloadSummary = function(accession, annotation_ids = NULL, symbols = NULL, locations = NULL, gene_types = NULL, search_text = NULL, sort_field = NULL, sort_direction = NULL, include_annotation_type = NULL, table_fields = NULL, table_format = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeAnnotationDownloadSummaryWithHttpInfo(accession, annotation_ids, symbols, locations, gene_types, search_text, sort_field, sort_direction, include_annotation_type, table_fields, table_format, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Preview feature dataset download
    #'
    #' @param accession 
    #' @param annotation_ids (optional) Limit the reports by internal, unstable annotation ids.
    #' @param symbols (optional) Filter parameters
    #' @param locations (optional) Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
    #' @param gene_types (optional) granular gene_types
    #' @param search_text (optional) No description
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_annotation_type (optional) No description
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param table_format (optional) Optional pre-defined template for processing a tabular data request
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    GenomeAnnotationDownloadSummaryWithHttpInfo = function(accession, annotation_ids = NULL, symbols = NULL, locations = NULL, gene_types = NULL, search_text = NULL, sort_field = NULL, sort_direction = NULL, include_annotation_type = NULL, table_fields = NULL, table_format = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }













      # explore
      for (query_item in `annotation_ids`) {
        query_params[["annotation_ids"]] <- c(query_params[["annotation_ids"]], list(`annotation_ids` = query_item))
      }

      # explore
      for (query_item in `symbols`) {
        query_params[["symbols"]] <- c(query_params[["symbols"]], list(`symbols` = query_item))
      }

      # explore
      for (query_item in `locations`) {
        query_params[["locations"]] <- c(query_params[["locations"]], list(`locations` = query_item))
      }

      # explore
      for (query_item in `gene_types`) {
        query_params[["gene_types"]] <- c(query_params[["gene_types"]], list(`gene_types` = query_item))
      }

      # explore
      for (query_item in `search_text`) {
        query_params[["search_text"]] <- c(query_params[["search_text"]], list(`search_text` = query_item))
      }

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      # explore
      for (query_item in `include_annotation_type`) {
        query_params[["include_annotation_type"]] <- c(query_params[["include_annotation_type"]], list(`include_annotation_type` = query_item))
      }

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["table_format"]] <- `table_format`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/accession/{accession}/annotation_report/download_summary"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Preview feature download by POST
    #'
    #' @param v2_genome_annotation_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    GenomeAnnotationDownloadSummaryByPost = function(v2_genome_annotation_request, data_file = NULL, ...) {
      local_var_response <- self$GenomeAnnotationDownloadSummaryByPostWithHttpInfo(v2_genome_annotation_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Preview feature download by POST
    #'
    #' @param v2_genome_annotation_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    GenomeAnnotationDownloadSummaryByPostWithHttpInfo = function(v2_genome_annotation_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_genome_annotation_request`)) {
        stop("Missing required parameter `v2_genome_annotation_request`.")
      }


      if (!is.null(`v2_genome_annotation_request`)) {
        local_var_body <- `v2_genome_annotation_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/annotation_report/download_summary"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get genome annotation reports by genome accession
    #'
    #' @param accession 
    #' @param annotation_ids (optional) Limit the reports by internal, unstable annotation ids.
    #' @param symbols (optional) Filter parameters
    #' @param locations (optional) Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
    #' @param gene_types (optional) granular gene_types
    #' @param search_text (optional) No description
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param page_size (optional) The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param table_format (optional) Optional pre-defined template for processing a tabular data request
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param page_token (optional) A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsGenomeAnnotationReportPage
    GenomeAnnotationReport = function(accession, annotation_ids = NULL, symbols = NULL, locations = NULL, gene_types = NULL, search_text = NULL, sort_field = NULL, sort_direction = NULL, page_size = 20, table_fields = NULL, table_format = NULL, include_tabular_header = NULL, page_token = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeAnnotationReportWithHttpInfo(accession, annotation_ids, symbols, locations, gene_types, search_text, sort_field, sort_direction, page_size, table_fields, table_format, include_tabular_header, page_token, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get genome annotation reports by genome accession
    #'
    #' @param accession 
    #' @param annotation_ids (optional) Limit the reports by internal, unstable annotation ids.
    #' @param symbols (optional) Filter parameters
    #' @param locations (optional) Locations with a chromosome or accession and optional start-stop range: chromosome|accession[:start-end]
    #' @param gene_types (optional) granular gene_types
    #' @param search_text (optional) No description
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param page_size (optional) The maximum number of features to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param table_fields (optional) Specify which fields to include in the tabular report
    #' @param table_format (optional) Optional pre-defined template for processing a tabular data request
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param page_token (optional) A page token is returned from a `GetFeatures` call with more than `page_size` results. Use this token, along with the previous `FeatureRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsGenomeAnnotationReportPage) with additional information such as HTTP status code, headers
    GenomeAnnotationReportWithHttpInfo = function(accession, annotation_ids = NULL, symbols = NULL, locations = NULL, gene_types = NULL, search_text = NULL, sort_field = NULL, sort_direction = NULL, page_size = 20, table_fields = NULL, table_format = NULL, include_tabular_header = NULL, page_token = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }














      # explore
      for (query_item in `annotation_ids`) {
        query_params[["annotation_ids"]] <- c(query_params[["annotation_ids"]], list(`annotation_ids` = query_item))
      }

      # explore
      for (query_item in `symbols`) {
        query_params[["symbols"]] <- c(query_params[["symbols"]], list(`symbols` = query_item))
      }

      # explore
      for (query_item in `locations`) {
        query_params[["locations"]] <- c(query_params[["locations"]], list(`locations` = query_item))
      }

      # explore
      for (query_item in `gene_types`) {
        query_params[["gene_types"]] <- c(query_params[["gene_types"]], list(`gene_types` = query_item))
      }

      # explore
      for (query_item in `search_text`) {
        query_params[["search_text"]] <- c(query_params[["search_text"]], list(`search_text` = query_item))
      }

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["page_size"]] <- `page_size`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["table_format"]] <- `table_format`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      query_params[["page_token"]] <- `page_token`

      local_var_url_path <- "/genome/accession/{accession}/annotation_report"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsGenomeAnnotationReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get genome annotation reports by genome accession
    #'
    #' @param v2_genome_annotation_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsGenomeAnnotationReportPage
    GenomeAnnotationReportByPost = function(v2_genome_annotation_request, data_file = NULL, ...) {
      local_var_response <- self$GenomeAnnotationReportByPostWithHttpInfo(v2_genome_annotation_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get genome annotation reports by genome accession
    #'
    #' @param v2_genome_annotation_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsGenomeAnnotationReportPage) with additional information such as HTTP status code, headers
    GenomeAnnotationReportByPostWithHttpInfo = function(v2_genome_annotation_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_genome_annotation_request`)) {
        stop("Missing required parameter `v2_genome_annotation_request`.")
      }


      if (!is.null(`v2_genome_annotation_request`)) {
        local_var_body <- `v2_genome_annotation_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/annotation_report"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsGenomeAnnotationReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by accessions
    #'
    #' @param accessions 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReport = function(accessions, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportWithHttpInfo(accessions, filters_reference_only, filters_assembly_source, filters_has_annotation, filters_exclude_paired_reports, filters_exclude_atypical, filters_assembly_version, filters_assembly_level, filters_first_release_date, filters_last_release_date, filters_search_text, filters_is_metagenome_derived, filters_is_type_material, filters_is_ictv_exemplar, filters_exclude_multi_isolate, filters_type_material_category, tax_exact_match, table_fields, returned_content, page_size, page_token, sort_field, sort_direction, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by accessions
    #'
    #' @param accessions 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportWithHttpInfo = function(accessions, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }

























      query_params[["filters.reference_only"]] <- `filters_reference_only`

      query_params[["filters.assembly_source"]] <- `filters_assembly_source`

      query_params[["filters.has_annotation"]] <- `filters_has_annotation`

      query_params[["filters.exclude_paired_reports"]] <- `filters_exclude_paired_reports`

      query_params[["filters.exclude_atypical"]] <- `filters_exclude_atypical`

      query_params[["filters.assembly_version"]] <- `filters_assembly_version`

      # explore
      for (query_item in `filters_assembly_level`) {
        query_params[["filters.assembly_level"]] <- c(query_params[["filters.assembly_level"]], list(`filters.assembly_level` = query_item))
      }

      query_params[["filters.first_release_date"]] <- `filters_first_release_date`

      query_params[["filters.last_release_date"]] <- `filters_last_release_date`

      # explore
      for (query_item in `filters_search_text`) {
        query_params[["filters.search_text"]] <- c(query_params[["filters.search_text"]], list(`filters.search_text` = query_item))
      }

      query_params[["filters.is_metagenome_derived"]] <- `filters_is_metagenome_derived`

      query_params[["filters.is_type_material"]] <- `filters_is_type_material`

      query_params[["filters.is_ictv_exemplar"]] <- `filters_is_ictv_exemplar`

      query_params[["filters.exclude_multi_isolate"]] <- `filters_exclude_multi_isolate`

      query_params[["filters.type_material_category"]] <- `filters_type_material_category`

      query_params[["tax_exact_match"]] <- `tax_exact_match`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["returned_content"]] <- `returned_content`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/accession/{accessions}/dataset_report"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by accessions
    #'
    #' @param v2_assembly_dataset_reports_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReportByPost = function(v2_assembly_dataset_reports_request, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportByPostWithHttpInfo(v2_assembly_dataset_reports_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by accessions
    #'
    #' @param v2_assembly_dataset_reports_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportByPostWithHttpInfo = function(v2_assembly_dataset_reports_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_dataset_reports_request`)) {
        stop("Missing required parameter `v2_assembly_dataset_reports_request`.")
      }


      if (!is.null(`v2_assembly_dataset_reports_request`)) {
        local_var_body <- `v2_assembly_dataset_reports_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/dataset_report"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by assembly name (exact)
    #'
    #' @param assembly_names 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReportsByAssemblyName = function(assembly_names, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportsByAssemblyNameWithHttpInfo(assembly_names, filters_reference_only, filters_assembly_source, filters_has_annotation, filters_exclude_paired_reports, filters_exclude_atypical, filters_assembly_version, filters_assembly_level, filters_first_release_date, filters_last_release_date, filters_search_text, filters_is_metagenome_derived, filters_is_type_material, filters_is_ictv_exemplar, filters_exclude_multi_isolate, filters_type_material_category, tax_exact_match, table_fields, returned_content, page_size, page_token, sort_field, sort_direction, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by assembly name (exact)
    #'
    #' @param assembly_names 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportsByAssemblyNameWithHttpInfo = function(assembly_names, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`assembly_names`)) {
        stop("Missing required parameter `assembly_names`.")
      }

























      query_params[["filters.reference_only"]] <- `filters_reference_only`

      query_params[["filters.assembly_source"]] <- `filters_assembly_source`

      query_params[["filters.has_annotation"]] <- `filters_has_annotation`

      query_params[["filters.exclude_paired_reports"]] <- `filters_exclude_paired_reports`

      query_params[["filters.exclude_atypical"]] <- `filters_exclude_atypical`

      query_params[["filters.assembly_version"]] <- `filters_assembly_version`

      # explore
      for (query_item in `filters_assembly_level`) {
        query_params[["filters.assembly_level"]] <- c(query_params[["filters.assembly_level"]], list(`filters.assembly_level` = query_item))
      }

      query_params[["filters.first_release_date"]] <- `filters_first_release_date`

      query_params[["filters.last_release_date"]] <- `filters_last_release_date`

      # explore
      for (query_item in `filters_search_text`) {
        query_params[["filters.search_text"]] <- c(query_params[["filters.search_text"]], list(`filters.search_text` = query_item))
      }

      query_params[["filters.is_metagenome_derived"]] <- `filters_is_metagenome_derived`

      query_params[["filters.is_type_material"]] <- `filters_is_type_material`

      query_params[["filters.is_ictv_exemplar"]] <- `filters_is_ictv_exemplar`

      query_params[["filters.exclude_multi_isolate"]] <- `filters_exclude_multi_isolate`

      query_params[["filters.type_material_category"]] <- `filters_type_material_category`

      query_params[["tax_exact_match"]] <- `tax_exact_match`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["returned_content"]] <- `returned_content`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/assembly_name/{assembly_names}/dataset_report"
      if (!missing(`assembly_names`)) {
        local_var_url_path <- gsub("\\{assembly_names\\}", paste(URLencode(as.character(`assembly_names`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by bioproject
    #'
    #' @param bioprojects 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReportsByBioproject = function(bioprojects, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportsByBioprojectWithHttpInfo(bioprojects, filters_reference_only, filters_assembly_source, filters_has_annotation, filters_exclude_paired_reports, filters_exclude_atypical, filters_assembly_version, filters_assembly_level, filters_first_release_date, filters_last_release_date, filters_search_text, filters_is_metagenome_derived, filters_is_type_material, filters_is_ictv_exemplar, filters_exclude_multi_isolate, filters_type_material_category, tax_exact_match, table_fields, returned_content, page_size, page_token, sort_field, sort_direction, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by bioproject
    #'
    #' @param bioprojects 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportsByBioprojectWithHttpInfo = function(bioprojects, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`bioprojects`)) {
        stop("Missing required parameter `bioprojects`.")
      }

























      query_params[["filters.reference_only"]] <- `filters_reference_only`

      query_params[["filters.assembly_source"]] <- `filters_assembly_source`

      query_params[["filters.has_annotation"]] <- `filters_has_annotation`

      query_params[["filters.exclude_paired_reports"]] <- `filters_exclude_paired_reports`

      query_params[["filters.exclude_atypical"]] <- `filters_exclude_atypical`

      query_params[["filters.assembly_version"]] <- `filters_assembly_version`

      # explore
      for (query_item in `filters_assembly_level`) {
        query_params[["filters.assembly_level"]] <- c(query_params[["filters.assembly_level"]], list(`filters.assembly_level` = query_item))
      }

      query_params[["filters.first_release_date"]] <- `filters_first_release_date`

      query_params[["filters.last_release_date"]] <- `filters_last_release_date`

      # explore
      for (query_item in `filters_search_text`) {
        query_params[["filters.search_text"]] <- c(query_params[["filters.search_text"]], list(`filters.search_text` = query_item))
      }

      query_params[["filters.is_metagenome_derived"]] <- `filters_is_metagenome_derived`

      query_params[["filters.is_type_material"]] <- `filters_is_type_material`

      query_params[["filters.is_ictv_exemplar"]] <- `filters_is_ictv_exemplar`

      query_params[["filters.exclude_multi_isolate"]] <- `filters_exclude_multi_isolate`

      query_params[["filters.type_material_category"]] <- `filters_type_material_category`

      query_params[["tax_exact_match"]] <- `tax_exact_match`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["returned_content"]] <- `returned_content`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/bioproject/{bioprojects}/dataset_report"
      if (!missing(`bioprojects`)) {
        local_var_url_path <- gsub("\\{bioprojects\\}", paste(URLencode(as.character(`bioprojects`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by biosample id
    #'
    #' @param biosample_ids 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReportsByBiosampleId = function(biosample_ids, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportsByBiosampleIdWithHttpInfo(biosample_ids, filters_reference_only, filters_assembly_source, filters_has_annotation, filters_exclude_paired_reports, filters_exclude_atypical, filters_assembly_version, filters_assembly_level, filters_first_release_date, filters_last_release_date, filters_search_text, filters_is_metagenome_derived, filters_is_type_material, filters_is_ictv_exemplar, filters_exclude_multi_isolate, filters_type_material_category, tax_exact_match, table_fields, returned_content, page_size, page_token, sort_field, sort_direction, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by biosample id
    #'
    #' @param biosample_ids 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportsByBiosampleIdWithHttpInfo = function(biosample_ids, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`biosample_ids`)) {
        stop("Missing required parameter `biosample_ids`.")
      }

























      query_params[["filters.reference_only"]] <- `filters_reference_only`

      query_params[["filters.assembly_source"]] <- `filters_assembly_source`

      query_params[["filters.has_annotation"]] <- `filters_has_annotation`

      query_params[["filters.exclude_paired_reports"]] <- `filters_exclude_paired_reports`

      query_params[["filters.exclude_atypical"]] <- `filters_exclude_atypical`

      query_params[["filters.assembly_version"]] <- `filters_assembly_version`

      # explore
      for (query_item in `filters_assembly_level`) {
        query_params[["filters.assembly_level"]] <- c(query_params[["filters.assembly_level"]], list(`filters.assembly_level` = query_item))
      }

      query_params[["filters.first_release_date"]] <- `filters_first_release_date`

      query_params[["filters.last_release_date"]] <- `filters_last_release_date`

      # explore
      for (query_item in `filters_search_text`) {
        query_params[["filters.search_text"]] <- c(query_params[["filters.search_text"]], list(`filters.search_text` = query_item))
      }

      query_params[["filters.is_metagenome_derived"]] <- `filters_is_metagenome_derived`

      query_params[["filters.is_type_material"]] <- `filters_is_type_material`

      query_params[["filters.is_ictv_exemplar"]] <- `filters_is_ictv_exemplar`

      query_params[["filters.exclude_multi_isolate"]] <- `filters_exclude_multi_isolate`

      query_params[["filters.type_material_category"]] <- `filters_type_material_category`

      query_params[["tax_exact_match"]] <- `tax_exact_match`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["returned_content"]] <- `returned_content`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/biosample/{biosample_ids}/dataset_report"
      if (!missing(`biosample_ids`)) {
        local_var_url_path <- gsub("\\{biosample_ids\\}", paste(URLencode(as.character(`biosample_ids`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by taxons
    #'
    #' @param taxons NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReportsByTaxon = function(taxons, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportsByTaxonWithHttpInfo(taxons, filters_reference_only, filters_assembly_source, filters_has_annotation, filters_exclude_paired_reports, filters_exclude_atypical, filters_assembly_version, filters_assembly_level, filters_first_release_date, filters_last_release_date, filters_search_text, filters_is_metagenome_derived, filters_is_type_material, filters_is_ictv_exemplar, filters_exclude_multi_isolate, filters_type_material_category, tax_exact_match, table_fields, returned_content, page_size, page_token, sort_field, sort_direction, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by taxons
    #'
    #' @param taxons NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportsByTaxonWithHttpInfo = function(taxons, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxons`)) {
        stop("Missing required parameter `taxons`.")
      }

























      query_params[["filters.reference_only"]] <- `filters_reference_only`

      query_params[["filters.assembly_source"]] <- `filters_assembly_source`

      query_params[["filters.has_annotation"]] <- `filters_has_annotation`

      query_params[["filters.exclude_paired_reports"]] <- `filters_exclude_paired_reports`

      query_params[["filters.exclude_atypical"]] <- `filters_exclude_atypical`

      query_params[["filters.assembly_version"]] <- `filters_assembly_version`

      # explore
      for (query_item in `filters_assembly_level`) {
        query_params[["filters.assembly_level"]] <- c(query_params[["filters.assembly_level"]], list(`filters.assembly_level` = query_item))
      }

      query_params[["filters.first_release_date"]] <- `filters_first_release_date`

      query_params[["filters.last_release_date"]] <- `filters_last_release_date`

      # explore
      for (query_item in `filters_search_text`) {
        query_params[["filters.search_text"]] <- c(query_params[["filters.search_text"]], list(`filters.search_text` = query_item))
      }

      query_params[["filters.is_metagenome_derived"]] <- `filters_is_metagenome_derived`

      query_params[["filters.is_type_material"]] <- `filters_is_type_material`

      query_params[["filters.is_ictv_exemplar"]] <- `filters_is_ictv_exemplar`

      query_params[["filters.exclude_multi_isolate"]] <- `filters_exclude_multi_isolate`

      query_params[["filters.type_material_category"]] <- `filters_type_material_category`

      query_params[["tax_exact_match"]] <- `tax_exact_match`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["returned_content"]] <- `returned_content`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/taxon/{taxons}/dataset_report"
      if (!missing(`taxons`)) {
        local_var_url_path <- gsub("\\{taxons\\}", paste(URLencode(as.character(`taxons`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get dataset reports by wgs accession
    #'
    #' @param wgs_accessions 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2reportsAssemblyDataReportPage
    GenomeDatasetReportsByWgs = function(wgs_accessions, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDatasetReportsByWgsWithHttpInfo(wgs_accessions, filters_reference_only, filters_assembly_source, filters_has_annotation, filters_exclude_paired_reports, filters_exclude_atypical, filters_assembly_version, filters_assembly_level, filters_first_release_date, filters_last_release_date, filters_search_text, filters_is_metagenome_derived, filters_is_type_material, filters_is_ictv_exemplar, filters_exclude_multi_isolate, filters_type_material_category, tax_exact_match, table_fields, returned_content, page_size, page_token, sort_field, sort_direction, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get dataset reports by wgs accession
    #'
    #' @param wgs_accessions 
    #' @param filters_reference_only (optional) If true, only return reference genome assemblies (default value: FALSE)
    #' @param filters_assembly_source (optional) Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
    #' @param filters_has_annotation (optional) Return only annotated genome assemblies (default value: FALSE)
    #' @param filters_exclude_paired_reports (optional) For paired (GCA/GCF) records, only return the primary record (default value: FALSE)
    #' @param filters_exclude_atypical (optional) If true, exclude atypical genomes, i.e. genomes that have assembly issues or are otherwise atypical (default value: FALSE)
    #' @param filters_assembly_version (optional) Return all assemblies, including replaced and suppressed, or only current assemblies
    #' @param filters_assembly_level (optional) Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
    #' @param filters_first_release_date (optional) Only return genome assemblies that were released on or after the specified date By default, do not filter.
    #' @param filters_last_release_date (optional) Only return genome assemblies that were released on or before to the specified date By default, do not filter.
    #' @param filters_search_text (optional) Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
    #' @param filters_is_metagenome_derived (optional) No description
    #' @param filters_is_type_material (optional) If true, include only type materials (default value: FALSE)
    #' @param filters_is_ictv_exemplar (optional) If true, include only ICTV Exemplars (default value: FALSE)
    #' @param filters_exclude_multi_isolate (optional) If true, exclude large multi-isolate projects (default value: FALSE)
    #' @param filters_type_material_category (optional) No description
    #' @param tax_exact_match (optional) If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. (default value: FALSE)
    #' @param table_fields (optional) No description
    #' @param returned_content (optional) Return either assembly accessions, or complete assembly reports
    #' @param page_size (optional) The maximum number of genome assembly reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `AssemblyDatasetReportsRequest` call with more than `page_size` results. Use this token, along with the previous `AssemblyDatasetReportsRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param sort_field (optional) No description
    #' @param sort_direction (optional) No description
    #' @param include_tabular_header (optional) Whether this request for tabular data should include the header row
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2reportsAssemblyDataReportPage) with additional information such as HTTP status code, headers
    GenomeDatasetReportsByWgsWithHttpInfo = function(wgs_accessions, filters_reference_only = FALSE, filters_assembly_source = NULL, filters_has_annotation = FALSE, filters_exclude_paired_reports = FALSE, filters_exclude_atypical = FALSE, filters_assembly_version = NULL, filters_assembly_level = NULL, filters_first_release_date = NULL, filters_last_release_date = NULL, filters_search_text = NULL, filters_is_metagenome_derived = NULL, filters_is_type_material = FALSE, filters_is_ictv_exemplar = FALSE, filters_exclude_multi_isolate = FALSE, filters_type_material_category = NULL, tax_exact_match = FALSE, table_fields = NULL, returned_content = NULL, page_size = 20, page_token = NULL, sort_field = NULL, sort_direction = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`wgs_accessions`)) {
        stop("Missing required parameter `wgs_accessions`.")
      }

























      query_params[["filters.reference_only"]] <- `filters_reference_only`

      query_params[["filters.assembly_source"]] <- `filters_assembly_source`

      query_params[["filters.has_annotation"]] <- `filters_has_annotation`

      query_params[["filters.exclude_paired_reports"]] <- `filters_exclude_paired_reports`

      query_params[["filters.exclude_atypical"]] <- `filters_exclude_atypical`

      query_params[["filters.assembly_version"]] <- `filters_assembly_version`

      # explore
      for (query_item in `filters_assembly_level`) {
        query_params[["filters.assembly_level"]] <- c(query_params[["filters.assembly_level"]], list(`filters.assembly_level` = query_item))
      }

      query_params[["filters.first_release_date"]] <- `filters_first_release_date`

      query_params[["filters.last_release_date"]] <- `filters_last_release_date`

      # explore
      for (query_item in `filters_search_text`) {
        query_params[["filters.search_text"]] <- c(query_params[["filters.search_text"]], list(`filters.search_text` = query_item))
      }

      query_params[["filters.is_metagenome_derived"]] <- `filters_is_metagenome_derived`

      query_params[["filters.is_type_material"]] <- `filters_is_type_material`

      query_params[["filters.is_ictv_exemplar"]] <- `filters_is_ictv_exemplar`

      query_params[["filters.exclude_multi_isolate"]] <- `filters_exclude_multi_isolate`

      query_params[["filters.type_material_category"]] <- `filters_type_material_category`

      query_params[["tax_exact_match"]] <- `tax_exact_match`

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["returned_content"]] <- `returned_content`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["sort.field"]] <- `sort_field`

      query_params[["sort.direction"]] <- `sort_direction`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/wgs/{wgs_accessions}/dataset_report"
      if (!missing(`wgs_accessions`)) {
        local_var_url_path <- gsub("\\{wgs_accessions\\}", paste(URLencode(as.character(`wgs_accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/x-ndjson", "text/tab-separated-values")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2reportsAssemblyDataReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Preview genome dataset download
    #'
    #' @param accessions NCBI genome assembly accessions
    #' @param chromosomes (optional) The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
    #' @param include_annotation_type (optional) Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    GenomeDownloadSummary = function(accessions, chromosomes = NULL, include_annotation_type = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeDownloadSummaryWithHttpInfo(accessions, chromosomes, include_annotation_type, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Preview genome dataset download
    #'
    #' @param accessions NCBI genome assembly accessions
    #' @param chromosomes (optional) The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
    #' @param include_annotation_type (optional) Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    GenomeDownloadSummaryWithHttpInfo = function(accessions, chromosomes = NULL, include_annotation_type = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }




      # explore
      for (query_item in `chromosomes`) {
        query_params[["chromosomes"]] <- c(query_params[["chromosomes"]], list(`chromosomes` = query_item))
      }

      # explore
      for (query_item in `include_annotation_type`) {
        query_params[["include_annotation_type"]] <- c(query_params[["include_annotation_type"]], list(`include_annotation_type` = query_item))
      }

      local_var_url_path <- "/genome/accession/{accessions}/download_summary"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Preview genome dataset download by POST
    #'
    #' @param v2_assembly_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2DownloadSummary
    GenomeDownloadSummaryByPost = function(v2_assembly_dataset_request, data_file = NULL, ...) {
      local_var_response <- self$GenomeDownloadSummaryByPostWithHttpInfo(v2_assembly_dataset_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Preview genome dataset download by POST
    #'
    #' @param v2_assembly_dataset_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2DownloadSummary) with additional information such as HTTP status code, headers
    GenomeDownloadSummaryByPostWithHttpInfo = function(v2_assembly_dataset_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_dataset_request`)) {
        stop("Missing required parameter `v2_assembly_dataset_request`.")
      }


      if (!is.null(`v2_assembly_dataset_request`)) {
        local_var_body <- `v2_assembly_dataset_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/download_summary"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2DownloadSummary"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get assembly links by accessions
    #'
    #' @param accessions NCBI genome assembly accessions, limited to 1000
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyLinksReply
    GenomeLinksByAccession = function(accessions, data_file = NULL, ...) {
      local_var_response <- self$GenomeLinksByAccessionWithHttpInfo(accessions, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get assembly links by accessions
    #'
    #' @param accessions NCBI genome assembly accessions, limited to 1000
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyLinksReply) with additional information such as HTTP status code, headers
    GenomeLinksByAccessionWithHttpInfo = function(accessions, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accessions`)) {
        stop("Missing required parameter `accessions`.")
      }


      local_var_url_path <- "/genome/accession/{accessions}/links"
      if (!missing(`accessions`)) {
        local_var_url_path <- gsub("\\{accessions\\}", paste(URLencode(as.character(`accessions`), reserved = TRUE), collapse= ",", sep=""), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyLinksReply"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get assembly links by accessions
    #'
    #' @param v2_assembly_links_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2AssemblyLinksReply
    GenomeLinksByAccessionByPost = function(v2_assembly_links_request, data_file = NULL, ...) {
      local_var_response <- self$GenomeLinksByAccessionByPostWithHttpInfo(v2_assembly_links_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get assembly links by accessions
    #'
    #' @param v2_assembly_links_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2AssemblyLinksReply) with additional information such as HTTP status code, headers
    GenomeLinksByAccessionByPostWithHttpInfo = function(v2_assembly_links_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_links_request`)) {
        stop("Missing required parameter `v2_assembly_links_request`.")
      }


      if (!is.null(`v2_assembly_links_request`)) {
        local_var_body <- `v2_assembly_links_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/links"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2AssemblyLinksReply"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get sequence reports by accessions
    #'
    #' @param accession 
    #' @param chromosomes (optional) No description
    #' @param role_filters (optional) No description
    #' @param table_fields (optional) No description
    #' @param count_assembly_unplaced (optional) No description (default value: FALSE)
    #' @param page_size (optional) The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `GetSequenceReports` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param include_tabular_header (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2SequenceReportPage
    GenomeSequenceReport = function(accession, chromosomes = NULL, role_filters = NULL, table_fields = NULL, count_assembly_unplaced = FALSE, page_size = 20, page_token = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      local_var_response <- self$GenomeSequenceReportWithHttpInfo(accession, chromosomes, role_filters, table_fields, count_assembly_unplaced, page_size, page_token, include_tabular_header, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get sequence reports by accessions
    #'
    #' @param accession 
    #' @param chromosomes (optional) No description
    #' @param role_filters (optional) No description
    #' @param table_fields (optional) No description
    #' @param count_assembly_unplaced (optional) No description (default value: FALSE)
    #' @param page_size (optional) The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, `page_token` can be used to retrieve the remaining results. (default value: 20)
    #' @param page_token (optional) A page token is returned from an `GetSequenceReports` call with more than `page_size` results. Use this token, along with the previous `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
    #' @param include_tabular_header (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2SequenceReportPage) with additional information such as HTTP status code, headers
    GenomeSequenceReportWithHttpInfo = function(accession, chromosomes = NULL, role_filters = NULL, table_fields = NULL, count_assembly_unplaced = FALSE, page_size = 20, page_token = NULL, include_tabular_header = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`accession`)) {
        stop("Missing required parameter `accession`.")
      }









      # explore
      for (query_item in `chromosomes`) {
        query_params[["chromosomes"]] <- c(query_params[["chromosomes"]], list(`chromosomes` = query_item))
      }

      # explore
      for (query_item in `role_filters`) {
        query_params[["role_filters"]] <- c(query_params[["role_filters"]], list(`role_filters` = query_item))
      }

      # explore
      for (query_item in `table_fields`) {
        query_params[["table_fields"]] <- c(query_params[["table_fields"]], list(`table_fields` = query_item))
      }

      query_params[["count_assembly_unplaced"]] <- `count_assembly_unplaced`

      query_params[["page_size"]] <- `page_size`

      query_params[["page_token"]] <- `page_token`

      query_params[["include_tabular_header"]] <- `include_tabular_header`

      local_var_url_path <- "/genome/accession/{accession}/sequence_reports"
      if (!missing(`accession`)) {
        local_var_url_path <- gsub("\\{accession\\}", URLencode(as.character(`accession`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "text/tab-separated-values", "application/x-ndjson")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2SequenceReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get sequence reports by accessions
    #'
    #' @param v2_assembly_sequence_reports_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return V2SequenceReportPage
    GenomeSequenceReportByPost = function(v2_assembly_sequence_reports_request, data_file = NULL, ...) {
      local_var_response <- self$GenomeSequenceReportByPostWithHttpInfo(v2_assembly_sequence_reports_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get sequence reports by accessions
    #'
    #' @param v2_assembly_sequence_reports_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (V2SequenceReportPage) with additional information such as HTTP status code, headers
    GenomeSequenceReportByPostWithHttpInfo = function(v2_assembly_sequence_reports_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`v2_assembly_sequence_reports_request`)) {
        stop("Missing required parameter `v2_assembly_sequence_reports_request`.")
      }


      if (!is.null(`v2_assembly_sequence_reports_request`)) {
        local_var_body <- `v2_assembly_sequence_reports_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/genome/sequence_reports"
      # API key authentication
      if ("api-key" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["api-key"]) > 0) {
        header_params["api-key"] <- paste(unlist(self$api_client$api_keys["api-key"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "text/tab-separated-values", "application/x-ndjson")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "V2SequenceReportPage"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
